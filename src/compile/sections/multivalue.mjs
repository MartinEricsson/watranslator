export function multivalueSection(functions, multiValueBlockTypes) {
    // Find multi-value control structures in functions
    for (const func of functions) {
        const collectMultiValueStructures = (instructions) => {
            if (!instructions) return;

            for (const instr of instructions) {
                // Generated by ðŸ¤–
                if (instr && instr.type && (instr.type === 'block' || instr.type === 'loop' || instr.type === 'if') &&
                    instr.resultType && Array.isArray(instr.resultType)) {
                    // Convert to a string to use for comparison
                    const typeKey = instr.resultType.join(',');
                    // If we haven't seen this type combination yet, add it
                    if (!multiValueBlockTypes.some(t => t.key === typeKey)) {
                        multiValueBlockTypes.push({
                            key: typeKey,
                            types: instr.resultType,
                            // Store a reference to the instruction to update its type index later
                            instructions: [instr]
                        });
                    } else {
                        // Add this instruction to the list of instructions using this type
                        const existingType = multiValueBlockTypes.find(t => t.key === typeKey);
                        existingType.instructions.push(instr);
                    }
                }

                // Recursively check nested instructions
                if (instr.instructions) {
                    collectMultiValueStructures(instr.instructions);
                }
                if (instr.thenInstructions) {
                    collectMultiValueStructures(instr.thenInstructions);
                }
                if (instr.elseInstructions) {
                    collectMultiValueStructures(instr.elseInstructions);
                }
            }
        };

        collectMultiValueStructures(func.instructions);
    }
}