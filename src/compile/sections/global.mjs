import wasmConstants from "../constants.mjs";
import {
    encodeULEB128,
    encodeSLEB128BigInt,
    encodeF64,
    getWasmType,
} from "../compile-utils.mjs";

const {
    INSTR,
    SECTION
} = wasmConstants;

export function globalSection(globals, binary) {
    // Filter out imported globals - Generated by ðŸ¤–
    const nonImportedGlobals = globals.filter(global => !global.import);
    
    if (nonImportedGlobals.length > 0) {
        let globalSection = [SECTION.GLOBAL]; // Section ID

        // Global entries count
        const globalEntries = [...encodeULEB128(nonImportedGlobals.length)];

        // Add each global entry
        for (const global of nonImportedGlobals) {
            // Global type - combination of value type and mutability flag
            globalEntries.push(getWasmType(global.type));
            globalEntries.push(global.mutable ? 1 : 0);

            // Initialization expression
            if (global.init) {
                if (global.init.type === 'i32.const') {
                    globalEntries.push(INSTR.I32_CONST);
                    globalEntries.push(...encodeULEB128(global.init.value));
                } else if (global.init.type === 'f32.const') {
                    globalEntries.push(INSTR.F32_CONST);

                    // Convert the float to its IEEE 754 representation
                    const buffer = new ArrayBuffer(4);
                    new Float32Array(buffer)[0] = global.init.value;
                    const bytes = new Uint8Array(buffer);
                    globalEntries.push(...bytes);
                } else if (global.init.type === 'i64.const') {
                    globalEntries.push(INSTR.I64_CONST);
                    globalEntries.push(...encodeSLEB128BigInt(global.init.value));
                } else if (global.init.type === 'f64.const') {
                    globalEntries.push(INSTR.F64_CONST);
                    globalEntries.push(...encodeF64(global.init.value));
                }
                // End the initialization expression
                globalEntries.push(INSTR.END);
            } else {
                // Default initialization (to zero)
                if (global.type === 'i32') {
                    globalEntries.push(INSTR.I32_CONST);
                    globalEntries.push(0);
                } else if (global.type === 'f32') {
                    globalEntries.push(INSTR.F32_CONST);
                    const buffer = new ArrayBuffer(4);
                    new Float32Array(buffer)[0] = 0.0;
                    const bytes = new Uint8Array(buffer);
                    globalEntries.push(...bytes);
                } else if (global.type === 'i64') {
                    globalEntries.push(INSTR.I64_CONST);
                    globalEntries.push(0);
                } else if (global.type === 'f64') {
                    globalEntries.push(INSTR.F64_CONST);
                    globalEntries.push(...encodeF64(0.0));
                }
                // End the initialization expression
                globalEntries.push(INSTR.END);
            }
        }

        // Section size
        globalSection.push(...encodeULEB128(globalEntries.length));

        // Section content
        globalSection.push(...globalEntries);

        binary.push(...globalSection);
    }
}