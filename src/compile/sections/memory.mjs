import wasmConstants from "../constants.mjs";
import { encodeULEB128 } from "../compile-utils.mjs";

const {
    SECTION,
} = wasmConstants;

// Generated by ðŸ¤–
export function memorySection(module, binary) {
    // Only emit a memory section if there are explicit memories
    if (module.memories && module.memories.length > 0) {
        const memorySection = [SECTION.MEMORY]; // Section ID
        const memoriesToProcess = module.memories.length > 1
            ? [...module.memories].sort((a, b) => {
                if (a.index !== null && b.index !== null) {
                    return a.index - b.index;
                }
                if (a.index !== null) return -1;
                if (b.index !== null) return 1;
                return 0;
            })
            : module.memories;

        // Memory entries count
        const memoryEntries = [...encodeULEB128(memoriesToProcess.length)];

        // Add each memory entry
        for (const memory of memoriesToProcess) {
            // Check if memory should be shared
            let needsSharedMemory = memory.shared || false;

            // Also check for atomic operations if not explicitly shared
            if (!needsSharedMemory && module.functions) {
                for (const func of module.functions) {
                    if (func.instructions?.some(instr => instr?.op?.includes('atomic'))) {
                        needsSharedMemory = true;
                        break;
                    }
                }
            }

            // For shared memory, ensure max is defined (WebAssembly requirement)
            let effectiveMax = memory.max;
            if (needsSharedMemory && effectiveMax === null) {
                // Set a reasonable default maximum if using shared memory (65536 = 4GB)
                effectiveMax = 65536;
            }

            // Flags - bit 0: has max, bit 1: is shared memory
            let flags = 0;
            if (effectiveMax !== null) flags |= 1;
            if (needsSharedMemory) flags |= 2;

            memoryEntries.push(flags);

            // Minimum size
            memoryEntries.push(...encodeULEB128(memory.min || 1)); // Default to 1 page if not specified

            // Maximum size (always include for shared memory)
            if (effectiveMax !== null) {
                memoryEntries.push(...encodeULEB128(effectiveMax));
            }
        }

        // Calculate section size
        const sectionSize = memoryEntries.length;
        memorySection.push(...encodeULEB128(sectionSize));
        memorySection.push(...memoryEntries);

        binary.push(...memorySection);
    }
}