import wasmConstants from "../constants.mjs";
import { encodeULEB128 } from "../compile-utils.mjs";

const {
    SECTION,
} = wasmConstants;

// Generated by ðŸ¤–
export function memorySection(module, binary) {
    if (module.memories && module.memories.length > 0) {
        let memorySection = [SECTION.MEMORY]; // Section ID

        // Sort memories by index if specified, otherwise keep original order
        const sortedMemories = [...module.memories].sort((a, b) => {
            if (a.index !== null && b.index !== null) {
                return a.index - b.index;
            }
            if (a.index !== null) return -1;
            if (b.index !== null) return 1;
            return 0;
        });

        // Memory entries count - THIS IS THE CRITICAL PART FOR MULTI-MEMORY
        const memoryEntries = [...encodeULEB128(sortedMemories.length)];

        // Add each memory entry
        for (const memory of sortedMemories) {
            // Check if memory should be shared
            let needsSharedMemory = memory.shared || false;

            // Also check for atomic operations if not explicitly shared
            if (!needsSharedMemory && module.functions) {
                for (const func of module.functions) {
                    if (func.instructions.some(instr => instr.op && instr.op.includes('atomic'))) {
                        needsSharedMemory = true;
                        break;
                    }
                }
            }

            // Check if there are data segments and ensure min is at least 1 page
            let effectiveMin = memory.min;
            if (module.datas && module.datas.length > 0 && effectiveMin === 0) {
                // If there are data segments, ensure at least 1 page of memory
                effectiveMin = 1;
            }

            // For shared memory, ensure max is defined (WebAssembly requirement)
            let effectiveMax = memory.max;
            if (needsSharedMemory && effectiveMax === null) {
                // Set a reasonable default maximum if using shared memory (65536 = 4GB)
                effectiveMax = 65536;
            }

            // Flags - bit 0: has max, bit 1: is shared memory
            let flags = 0;
            if (effectiveMax !== null) flags |= 1;
            if (needsSharedMemory) flags |= 2;

            memoryEntries.push(flags);

            // Minimum size - use the potentially adjusted value
            memoryEntries.push(...encodeULEB128(effectiveMin));

            // Maximum size (always include for shared memory)
            if (effectiveMax !== null) {
                memoryEntries.push(...encodeULEB128(effectiveMax));
            }
        }

        // Calculate section size
        const sectionSize = memoryEntries.length;
        memorySection.push(...encodeULEB128(sectionSize));

        // Add section content
        memorySection.push(...memoryEntries);

        binary.push(...memorySection);
    } else if (module.datas && module.datas.length > 0) {
        // If we have data segments but no explicit memory, create a default memory section
        let memorySection = [SECTION.MEMORY]; // Section ID

        // Just one memory entry
        const memoryEntries = [...encodeULEB128(1)];

        // No flags, initial size of 1 page
        memoryEntries.push(0); // No flags
        memoryEntries.push(...encodeULEB128(1)); // Min size = 1 page

        // Calculate section size
        const sectionSize = memoryEntries.length;
        memorySection.push(...encodeULEB128(sectionSize));

        // Add section content
        memorySection.push(...memoryEntries);

        binary.push(...memorySection);
    }
}