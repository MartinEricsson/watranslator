import wasmConstants from "../constants.mjs";
import { encodeULEB128 } from "../compile-utils.mjs";

const {
    SECTION,
} = wasmConstants;

// Generated by ðŸ¤–
export function memorySection(module, binary) {
    if (module.memories && module.memories.length > 0) {
        let memorySection = [SECTION.MEMORY]; // Section ID

        // Memory entries count
        const memoryEntries = [...encodeULEB128(module.memories.length)];

        // Add each memory entry
        for (const memory of module.memories) {
            // Check if memory should be shared
            let needsSharedMemory = memory.shared || false; // Generated by ðŸ¤–
            
            // Also check for atomic operations if not explicitly shared
            if (!needsSharedMemory && module.functions) { // Generated by ðŸ¤–
                for (const func of module.functions) {
                    if (func.instructions.some(instr => instr.op && instr.op.includes('atomic'))) {
                        needsSharedMemory = true;
                        break;
                    }
                }
            }

            // For shared memory, ensure max is defined (WebAssembly requirement)
            let effectiveMax = memory.max;
            if (needsSharedMemory && effectiveMax === null) {
                // Set a reasonable default maximum if using shared memory (65536 = 4GB)
                effectiveMax = 65536;
            }

            // Flags - bit 0: has max, bit 1: is shared memory
            let flags = 0;
            if (effectiveMax !== null) flags |= 1;
            if (needsSharedMemory) flags |= 2; // Set shared memory flag

            memoryEntries.push(flags);

            // Minimum size
            memoryEntries.push(...encodeULEB128(memory.min));

            // Maximum size (always include for shared memory)
            if (effectiveMax !== null) {
                memoryEntries.push(...encodeULEB128(effectiveMax));
            }
        }

        // Section size
        memorySection.push(...encodeULEB128(memoryEntries.length));

        // Section content
        memorySection.push(...memoryEntries);

        binary.push(...memorySection);
    }
}