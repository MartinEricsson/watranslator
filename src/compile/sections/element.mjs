import wasmConstants from "../constants.mjs";
import { 
    encodeULEB128,
    encodeSLEB128,
 } from "../compile-utils.mjs";

const {
    INSTR,
    SECTION,
} = wasmConstants;

export function elementSection(elements, functions, binary) {
    // Generated by ðŸ¤–
    if (elements.length > 0) {
        let elementSection = [SECTION.ELEMENT]; // Section ID (9)

        // Count of element segments
        const elementEntries = [...encodeULEB128(elements.length)];

        // Process each element segment
        for (const element of elements) {
            // Active element segment (mode 0x00: active with expression)
            elementEntries.push(0x00); // Mode: active, table index 0

            // Offset expression for this segment
            elementEntries.push(INSTR.I32_CONST);  // i32.const
            elementEntries.push(...encodeSLEB128(element.offset)); // offset value
            elementEntries.push(INSTR.END);        // end of offset expression

            // Count of function indices in this segment
            elementEntries.push(...encodeULEB128(element.functionIndices.length));

            // Function indices
            for (const funcRef of element.functionIndices) {
                // Convert function reference to index
                let funcIndex;

                if (typeof funcRef === 'string' && funcRef.startsWith('$')) {
                    // Look up function index by name
                    funcIndex = functions.findIndex(f => f.name === funcRef);
                    if (funcIndex === -1) {
                        throw new Error(`Unknown function reference in element section: ${funcRef}`);
                    }
                } else {
                    // Direct numeric index
                    funcIndex = parseInt(funcRef, 10) || 0;
                }

                // Add function index to element entries
                elementEntries.push(...encodeULEB128(funcIndex));
            }
        }

        // Section size
        elementSection.push(...encodeULEB128(elementEntries.length));

        // Section content
        elementSection.push(...elementEntries);

        binary.push(...elementSection);
    }
}