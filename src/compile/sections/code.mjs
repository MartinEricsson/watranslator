import { compileInstruction } from '../instructions/instructions.mjs';
import wasmConstants from "../constants.mjs";
import {
    encodeULEB128,
    getWasmType
} from "../compile-utils.mjs";

const {
    INSTR,
    SECTION,
} = wasmConstants;


export function codeSection(functions, globals, module, binary) {
    // Fix the code section generation to properly track and debug function bytecode
    if (functions.length > 0) {
        // Generated by ðŸ¤–
        // Filter out imported functions that don't have a body
        const nonImportedFunctions = functions.filter(func => !func.import);
        
        if (nonImportedFunctions.length === 0) {
            return;
        }
        
        let codeSection = [SECTION.CODE]; // Section ID

        // Function bodies count
        const codeBodies = [...encodeULEB128(nonImportedFunctions.length)];

        // For each function
        for (const func of nonImportedFunctions) {
            const body = [];

            // Local declarations - group locals by type
            const localsByType = {};
            // Create a mapping from original local index to reordered index
            func.localMap = new Map();
            
            // Store param count for offset calculation
            const paramCount = func.parameters ? func.parameters.length : 0;
            
            if (func.locals && func.locals.length > 0) {
                for (const local of func.locals) {
                    const type = getWasmType(local.type);
                    if (!localsByType[type]) {
                        localsByType[type] = [];
                    }
                    localsByType[type].push(local);
                }
            }

            // Encode locals - count of local variable types
            const localEntries = Object.entries(localsByType);
            body.push(...encodeULEB128(localEntries.length));

            // For each type, encode count and type
            let newLocalIndex = paramCount; // Start after parameters
            for (const [typeValue, locals] of localEntries) {
                body.push(...encodeULEB128(locals.length)); // Count of locals with this type
                body.push(parseInt(typeValue, 10));         // Type of locals
                
                // Update mapping for each local in this type group
                for (const local of locals) {
                    // Find the original index of this local
                    const origIndex = func.locals.indexOf(local) + paramCount;
                    // Map it to its new index after reordering
                    func.localMap.set(origIndex, newLocalIndex);
                    newLocalIndex++;
                }
            }

            // Function instructions
            for (const instr of func.instructions) {
                compileInstruction(instr, func, body, functions, globals, module);
            }

            // End opcode
            body.push(INSTR.END);
            // Function body size and content
            codeBodies.push(...encodeULEB128(body.length));
            codeBodies.push(...body);
        }

        // Section size
        codeSection.push(...encodeULEB128(codeBodies.length));

        // Section content
        codeSection.push(...codeBodies);

        binary.push(...codeSection);
    }
}