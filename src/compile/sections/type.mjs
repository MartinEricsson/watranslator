import wasmConstants from "../constants.mjs";
import { encodeULEB128, getWasmType } from "../compile-utils.mjs";
import { createError } from "../instructions/error.mjs";
const {
    SECTION,
} = wasmConstants;

// Generated by ðŸ¤–
function compileFunctionType(func) {
    // Function type tag
    const typeSectionContent = [0x60]; // Function type

    // Param types
    const paramTypes = func.parameters.map(param => getWasmType(param.type));
    typeSectionContent.push(...encodeULEB128(paramTypes.length));
    typeSectionContent.push(...paramTypes);

    // Result types - properly handle multi-value returns
    let resultTypes = [];
    try {
        if (func.results && Array.isArray(func.results)) {
            resultTypes = func.results.map(getWasmType);
        }
    } catch (e) {
        throw createError(null, func, null, e.message);
    }

    typeSectionContent.push(...encodeULEB128(resultTypes.length));
    typeSectionContent.push(...resultTypes);

    return typeSectionContent;
}

export function typeSection(functions, multiValueBlockTypes, binary) {
    // =================== TYPE SECTION ===================
    if (functions.length > 0 || multiValueBlockTypes.length > 0) {
        // Encode types for all functions
        let typeSection = [SECTION.TYPE]; // Section ID

        // Calculate total number of types needed
        const numTypes = functions.length + multiValueBlockTypes.length;
        const typesVector = [...encodeULEB128(numTypes)];

        // Function type entries
        for (const func of functions) {
            // Add function type using the compileFunctionType helper
            typesVector.push(...compileFunctionType(func));
        }

        // Add types for multi-value blocks
        for (let i = 0; i < multiValueBlockTypes.length; i++) {
            const blockType = multiValueBlockTypes[i];

            // Store the type index for this block type (functions.length + i)
            blockType.typeIndex = functions.length + i;

            // Function type tag
            typesVector.push(0x60); // func type

            // No parameters for blocks
            typesVector.push(0x00);

            // Result types
            const resultTypes = blockType.types.map(getWasmType);
            typesVector.push(...encodeULEB128(resultTypes.length));
            typesVector.push(...resultTypes);

            // Assign the type index to all instructions using this type
            for (const instr of blockType.instructions) {
                instr.typeIndex = blockType.typeIndex;
            }
        }

        // Section size
        typeSection.push(...encodeULEB128(typesVector.length));

        // Section content
        typeSection.push(...typesVector);

        binary.push(...typeSection);
    }
}