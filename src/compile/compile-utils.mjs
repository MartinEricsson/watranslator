import wasmConstants from './constants.mjs';

const {
    TYPE,
} = wasmConstants;

// Helper function to encode unsigned LEB128 integer
export function encodeULEB128(value) {
    const result = [];
    do {
        let byte = value & 0x7F;
        value >>>= 7;
        if (value !== 0) {
            byte |= 0x80;
        }
        result.push(byte);
    } while (value !== 0);
    return result;
}

// Helper function to encode signed LEB128 integer for data section offsets
export function encodeSLEB128(value) {
    const result = [];
    let more = true;

    while (more) {
        let byte = value & 0x7F;
        value >>= 7;

        // Sign bit of byte is second high order bit (0x40)
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        } else {
            byte |= 0x80; // Mark this byte to show that more bytes will follow
        }

        result.push(byte);
    }

    return result;
}

// Helper function to encode signed LEB128 integer from BigInt values for i64.const
export function encodeSLEB128BigInt(value) {
    const result = [];
    let more = true;

    // Make sure we're working with a BigInt
    if (typeof value !== 'bigint') {
        value = BigInt(value);
    }

    while (more) {
        // Extract the 7 least significant bits
        let byte = Number(value & BigInt(0x7F));

        // Arithmetic shift right by 7 bits (preserves sign)
        value = value >> BigInt(7);

        // Determine if this is the last byte we need
        // For positive numbers, we're done when the remaining value is 0 and the sign bit in byte is not set
        // For negative numbers, we're done when the remaining value is -1 and the sign bit in byte is set
        if ((value === BigInt(0) && (byte & 0x40) === 0) || (value === BigInt(-1) && (byte & 0x40) !== 0)) {
            more = false;
        } else {
            // More bytes to come
            byte |= 0x80;
        }

        result.push(byte);
    }

    return result;
}

// Helper function to encode string
export function encodeString(str) {
    const utf8Encoder = new TextEncoder();
    const bytes = utf8Encoder.encode(str);
    return [
        ...encodeULEB128(bytes.length),
        ...Array.from(bytes)
    ];
}

// Helper function to encode f64 value to IEEE 754 bytes
// Generated by 🤖
export function encodeF64(value) {
    const buffer = new ArrayBuffer(8);
    new Float64Array(buffer)[0] = value;
    return Array.from(new Uint8Array(buffer));
}

// Helper function to encode f32 value to IEEE 754 bytes
// Generated by 🤖
export function encodeF32(value) {
    const buffer = new ArrayBuffer(4);
    new Float32Array(buffer)[0] = value;
    return Array.from(new Uint8Array(buffer));
}

// Helper function to encode bytes from WAT data section strings
export function encodeBytes(str) {
    console.log("Raw string to encode:", str);

    // Special handler for WAT data section format
    // In WAT, data section strings look like "\01\02\03" with single backslashes
    // but in JS strings these are represented as "\\01\\02\\03"
    if (str.includes('\\\\')) {
        const bytes = [];
        let i = 0;

        while (i < str.length) {
            if (str[i] === '\\' && str[i + 1] === '\\') {
                // Skip the double backslash and process the WAT escape sequence
                i += 2; // Skip both backslashes
                if (i < str.length) {
                    const c = str[i];

                    // Handle numeric escapes (\0-\9)
                    if (c >= '0' && c <= '9') {
                        bytes.push(parseInt(c, 10));
                    }
                    // Handle hex escapes
                    else if ((c === 'f' || c === 'F') && i + 1 < str.length && (str[i + 1] === 'f' || str[i + 1] === 'F')) {
                        bytes.push(255); // \ff = 0xFF = 255
                        i++; // Skip the second 'f'
                    }
                    else if ((c === 'f' || c === 'F') && i + 1 < str.length && (str[i + 1] === 'e' || str[i + 1] === 'E')) {
                        bytes.push(254); // \fe = 0xFE = 254
                        i++; // Skip the 'e'
                    }
                    // Other escapes if needed...
                    else {
                        bytes.push(str.charCodeAt(i));
                    }
                }
                i++;
            } else {
                bytes.push(str.charCodeAt(i));
                i++;
            }
        }

        console.log("Encoded bytes:", bytes);
        return bytes;
    }

    // This is the normal case for regular strings
    const bytes = [];

    for (let i = 0; i < str.length; i++) {
        if (str[i] === '\\') {
            i++;
            if (i < str.length) {
                const c = str[i];
                if (c >= '0' && c <= '9') {
                    bytes.push(parseInt(c, 10));
                } else if (c === 'f') {
                    if (i + 1 < str.length && str[i + 1] === 'f') {
                        bytes.push(255);
                        i++;
                    } else {
                        bytes.push(15);
                    }
                } else if (c === 'e') {
                    if (i + 1 < str.length && str[i + 1] === 'e') {
                        bytes.push(254);
                        i++;
                    } else {
                        bytes.push(14);
                    }
                } else if (c === 't') bytes.push(9);
                else if (c === 'n') bytes.push(10);
                else if (c === 'r') bytes.push(13);
                else if (c === '"') bytes.push(34);
                else if (c === '\'') bytes.push(39);
                else if (c === '\\') bytes.push(92);
            }
        } else {
            bytes.push(str.charCodeAt(i));
        }
    }

    console.log("Encoded bytes:", bytes);
    return bytes;
}

// Generated by 🤖
// Helper function to determine natural alignment for memory instructions
export function getInstructionNaturalAlignment(instrType) {
    // Natural alignment is log2 of the size in bytes
    switch (instrType) {
        case 'i32.load':
        case 'f32.load':
        case 'i32.store':
        case 'f32.store':
            return 2;  // 4 bytes = 2^2

        case 'i64.load':
        case 'f64.load':
        case 'i64.store':
        case 'f64.store':
            return 3;  // 8 bytes = 2^3

        case 'i32.load16_s':
        case 'i32.load16_u':
        case 'i64.load16_s':
        case 'i64.load16_u':
        case 'i32.store16':
        case 'i64.store16':
            return 1;  // 2 bytes = 2^1

        case 'i32.load8_s':
        case 'i32.load8_u':
        case 'i64.load8_s':
        case 'i64.load8_u':
        case 'i32.store8':
        case 'i64.store8':
            return 0;  // 1 byte = 2^0

        case 'i64.load32_s':
        case 'i64.load32_u':
        case 'i64.store32':
            return 2;  // 4 bytes = 2^2

        default:
            return 0;  // Default to byte alignment
    }
}

// Convert WAT type string to binary type
export function getWasmType(type) {
    switch (type) {
        case 'i32': return TYPE.I32;
        case 'i64': return TYPE.I64;
        case 'f32': return TYPE.F32;
        case 'f64': return TYPE.F64;
        case 'v128': return TYPE.V128;
        case 'funcref': return TYPE.FUNCREF;
        case 'externref': return TYPE.EXTERNREF;
        case 'anyref': return TYPE.ANYREF;
        default: {
            let err = new Error(`Unknown type: ${type}`);
            err.context = {
                type: type,
                expectedTypes: ['i32', 'i64', 'f32', 'f64', 'v128', 'funcref', 'externref', 'anyref'],
                position: {
                    line: 0, // Placeholder for line number
                    column: 0, // Placeholder for column number
                },
            };
            throw err;
        }
    }
}

// Helper function to resolve label references to label indices
export function getLabelIndex(label, func) {
    // Generated by 🤖
    // In WebAssembly, branch indices are depths in the control structure stack
    // For loops, we need to branch to 0 (the loop itself) to continue the loop
    // For blocks, we need to branch to the block's parent depth to exit the block

    // If label is a number or numeric string, use it directly
    if (typeof label === 'number' || (typeof label === 'string' && !isNaN(parseInt(label)))) {
        return parseInt(label);
    }

    // For named labels, we need to count block nesting levels from innermost to outermost
    let blocks = [];
    let blockTypes = [];  // Store the type of each block ('block', 'loop', etc.)
    let foundTable = false;
    let isDefault = false;

    // Collect all blocks in order from outermost to innermost until we find br_table
    const collectBlocks = (instructions) => {
        if (foundTable) return;

        for (const instr of instructions) {
            if (foundTable) break;

            if (instr.type === 'block' || instr.type === 'loop') {
                blocks.push(instr.label);
                blockTypes.push(instr.type);
                collectBlocks(instr.instructions);
            } else if (instr.type === 'br_table') {
                // Check if this label is the default label
                isDefault = instr.defaultLabel === label;
                if (isDefault || (instr.labels && instr.labels.includes(label))) {
                    foundTable = true;
                    break;
                }
            }
        }
    };

    // Find the blocks and br_table
    if (func && func.instructions) {
        collectBlocks(func.instructions);
    }

    // If we found br_table, count from innermost to target label
    if (foundTable && blocks.length > 0) {
        // Reverse blocks and blockTypes to get innermost to outermost order
        blocks.reverse();
        blockTypes.reverse();
        // For default label, always return index to outermost block
        if (isDefault) {
            return blocks.length - 1;
        }
        // Find the target label's position
        const targetIndex = blocks.indexOf(label);
        if (targetIndex !== -1) {
            return targetIndex;
        }
    }

    // For regular branches (not part of br_table)
    if (blocks.length > 0) {
        // Reverse to get innermost to outermost order if not already done
        if (!foundTable) {
            blocks.reverse();
            blockTypes.reverse();
        }

        // Find the index of the label we're targeting
        const labelIndex = blocks.indexOf(label);
        if (labelIndex !== -1) {
            const blockType = blockTypes[labelIndex];

            // Important WAT/WASM semantics:
            // - For loops: returning to the start of loop requires depth 0 (continue loop)
            // - For blocks: exiting requires the appropriate relative depth
            if (blockType === 'loop' && label !== '$break') {
                // For loop labels, we always use 0 to branch to the loop start
                return 0;
            } else {
                // For blocks or breaking out of loops, use the proper depth
                return labelIndex;
            }
        }
    }

    return 0; // Default depth if label not found
}

// Fix and clean up the AST if needed
export function sanitizeAST(ast) {
    if (!ast || !Array.isArray(ast) || ast.length === 0) {
        throw new Error('Invalid AST structure');
    }

    // Find the module object in the AST
    const moduleObj = ast.find(item => item && typeof item === 'object' && 'functions' in item);

    if (!moduleObj) {
        throw new Error('No module found in AST');
    }

    // Initialize module properties
    moduleObj.exports = moduleObj.exports || {};
    moduleObj.functions = moduleObj.functions || [];
    
    // Clear any existing functions to rebuild them properly
    const originalInModuleFunctions = [...moduleObj.functions];
    
    // Reset functions array
    moduleObj.functions = [];
    
    // Re-add original functions from the module
    moduleObj.functions.push(...originalInModuleFunctions);
    
    // Find all standalone function objects in the AST (outside the module object)
    const funcs = ast.filter(item => 
        item && typeof item === 'object' && 
        Array.isArray(item.instructions) && 
        item !== moduleObj
    );
    
    // Process standalone functions
    funcs.forEach((func) => {
        // Add to module's functions array
        moduleObj.functions.push(func);
        
        // Handle exports - the index is the current length - 1
        if (func.export && typeof func.export === 'string') {
            moduleObj.exports[func.export] = {
                kind: 'func',
                index: moduleObj.functions.length - 1
            };
        }
    });

    return moduleObj; // Generated by 🤖
}