import wasmConstants from "../constants.mjs";
import { createError } from "./error.mjs";

const {
    INSTR
} = wasmConstants;

export function compileTableInstruction(instr, func, module, body) {
    if (instr.type === 'table.init') {
        try {
            // Validate element index exists
            if (module.elements && instr.elementIndex >= module.elements.length) {
                throw createError(instr, func, module, `Element segment ${instr.elementIndex} does not exist. Module has ${module.elements.length} element segments.`);
            }

            // Validate table index exists
            if (module.tables && instr.tableIndex >= module.tables.length) {
                throw createError(instr, func, module, `Table index ${instr.tableIndex} is out of bounds. Module has ${module.tables.length} tables.`);
            }

            body.push(INSTR.BULK_PREFIX);
            body.push(INSTR.TABLE_INIT);
            body.push(instr.elementIndex); // Element segment index
            body.push(instr.tableIndex);   // Table index
            return true;
        } catch (err) {
            if (err.message.includes("is out of bounds") || err.message.includes("does not exist")) {
                throw createError(instr, func, module, err.message); // Use our enhanced error message
            }
            throw createError(instr, func, module, `Invalid table.init instruction: ${err.message}`);
        }
    } else if (instr.type === 'table.size') {
        try {
            body.push(INSTR.BULK_PREFIX);
            body.push(INSTR.TABLE_SIZE);
            body.push(instr.tableIndex);
            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid table.size instruction: ${err.message}`);
        }
    } else if (instr.type === 'table.grow') {
        // Generated by ðŸ¤–
        try {
            // Validate table index exists
            if (module.tables && instr.tableIndex >= module.tables.length) {
                throw createError(instr, func, module, `Table index ${instr.tableIndex} is out of bounds. Module has ${module.tables.length} tables.`);
            }

            body.push(INSTR.BULK_PREFIX);
            body.push(INSTR.TABLE_GROW);
            body.push(instr.tableIndex);
            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid table.grow instruction: ${err.message}`);
        }
    } else if (instr.type === 'table.get') {
        try {
            body.push(INSTR.TABLE_GET);
            body.push(instr.tableIndex);
            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid table.get instruction: ${err.message}`);
        }
    } else if (instr.type === 'table.copy') {
        // Generated by ðŸ¤–
        try {
            // Validate table indices exist
            if (module.tables && (instr.destTableIndex >= module.tables.length || instr.srcTableIndex >= module.tables.length)) {
                throw createError(instr, func, module, `Table index out of bounds. Module has ${module.tables.length} tables.`);
            }

            body.push(INSTR.BULK_PREFIX);
            body.push(INSTR.TABLE_COPY);
            body.push(instr.destTableIndex); // Destination table index
            body.push(instr.srcTableIndex);  // Source table index
            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid table.copy instruction: ${err.message}`);
        }
    } else if (instr.type === 'table.set') {
        try {
            body.push(INSTR.TABLE_SET);
            body.push(instr.tableIndex);
            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid table.set instruction: ${err.message}`);
        }
    } else if (instr.type === 'elem.drop') {
        // Generated by ðŸ¤–
        try {
            // Validate element index exists
            if (module.elements && instr.elementIdx >= module.elements.length) {
                throw createError(instr, func, module, `Element segment ${instr.elementIdx} does not exist. Module has ${module.elements.length} element segments.`);
            }

            body.push(INSTR.BULK_PREFIX);    // 0xFC prefix for bulk memory operations
            body.push(INSTR.ELEM_DROP);      // opcode for elem.drop
            body.push(instr.elementIdx);     // Element segment index
            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid elem.drop instruction: ${err.message}`);
        }
    } else if (instr.type === 'table.fill') {
        try {
            // Validate table index exists
            if (module.tables && instr.tableIndex >= module.tables.length) {
                throw createError(instr, func, module, `Table index ${instr.tableIndex} is out of bounds. Module has ${module.tables.length} tables.`);
            }

            body.push(INSTR.BULK_PREFIX);    // 0xFC prefix for bulk memory operations
            body.push(INSTR.TABLE_FILL);     // table.fill opcode
            body.push(instr.tableIndex);     // Table index
            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid table.fill instruction: ${err.message}`);
        }
    }

    return false;
}