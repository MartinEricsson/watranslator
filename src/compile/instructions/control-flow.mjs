import wasmConstants from "../constants.mjs";
import {
    encodeULEB128,
    encodeSLEB128,
    getWasmType,
    getLabelIndex
} from "../compile-utils.mjs";
import { createError } from "./error.mjs";
import { compileInstruction } from "./instructions.mjs";

const {
    INSTR,
    TYPE
} = wasmConstants;

export function compileControlFlow(instr, func, body, moduleFunctions, moduleGlobals, module) {
    if (instr.type === 'select_t') {
        // Handle typed select instruction: select (result <type>)
        body.push(INSTR.SELECT_T);

        // For select_t, we need to provide the vector of types (currently always 1)
        body.push(0x01); // Vector length (1 type)

        // Add the result type
        if (instr.resultType) {
            try {
                body.push(getWasmType(instr.resultType));
            } catch (err) {
                throw createError(instr, func, module, `Invalid select_t result type: ${instr.resultType}`);
            }
        } else {
            // Default to i32 if type not specified
            body.push(TYPE.I32);
        }

        return true;
    }

    if (instr.type === 'block') {
        body.push(INSTR.BLOCK);

        // Generated by 
        // For multi-value blocks, we need to use a function type index
        if (instr.typeIndex !== undefined) {
            // Use the type index assigned during type section generation
            body.push(...encodeSLEB128(instr.typeIndex));
        } else if (instr.resultType) {
            try {
                // Single result type
                body.push(getWasmType(instr.resultType));
            } catch (err) {
                throw createError(instr, func, module, `Invalid block result type: ${instr.resultType}`);
            }
        } else {
            body.push(TYPE.BLOCK_VOID); // No value type
        }

        // Recursively compile instructions inside the block
        for (const nestedInstr of instr.instructions) {
            compileInstruction(nestedInstr, func, body, moduleFunctions, moduleGlobals, module);
        }
        // End block
        body.push(INSTR.END);

        return true;
    }

    if (instr.type === 'loop') {
        body.push(INSTR.LOOP);

        // Generated by 
        // For multi-value loops, we need to use a function type index
        if (instr.typeIndex !== undefined) {
            // Use the type index assigned during type section generation
            body.push(...encodeSLEB128(instr.typeIndex));
        } else if (instr.resultType) {
            try {
                // Single result type
                body.push(getWasmType(instr.resultType));
            } catch (err) {
                throw createError(instr, func, module, `Invalid loop result type: ${instr.resultType}`);
            }
        } else {
            body.push(TYPE.BLOCK_VOID); // No value type
        }

        // Recursively compile instructions inside the loop
        for (const nestedInstr of instr.instructions) {
            compileInstruction(nestedInstr, func, body, moduleFunctions, moduleGlobals, module);
        }
        // End loop
        body.push(INSTR.END);

        return true;
    }

    if (instr.type === 'if') {
        body.push(INSTR.IF);

        // Generated by 
        // For multi-value ifs, we need to use a function type index
        if (instr.typeIndex !== undefined) {
            // Use the type index assigned during type section generation
            body.push(...encodeSLEB128(instr.typeIndex));
        } else if (instr.resultType) {
            try {
                // Single result type
                body.push(getWasmType(instr.resultType));
            } catch (err) {
                throw createError(instr, func, module, `Invalid if result type: ${instr.resultType}`);
            }
        } else {
            body.push(TYPE.BLOCK_VOID); // No value type
        }

        // Compile then branch instructions
        for (const thenInstr of instr.thenInstructions) {
            compileInstruction(thenInstr, func, body, moduleFunctions, moduleGlobals, module);
        }

        // If there are else branch instructions, add else opcode and compile them
        if (instr.elseInstructions && instr.elseInstructions.length > 0) {
            body.push(INSTR.ELSE);

            for (const elseInstr of instr.elseInstructions) {
                compileInstruction(elseInstr, func, body, moduleFunctions, moduleGlobals, module);
            }
        }

        // End if
        body.push(INSTR.END);

        return true;
    }

    if (instr.type === 'br') {
        body.push(INSTR.BR);

        try {
            // Branch target (label depth)
            const labelIndex = getLabelIndex(instr.label, func);
            body.push(...encodeULEB128(labelIndex));
        } catch (err) {
            throw createError(instr, func, module, `Invalid branch target: ${instr.label}. Make sure the label exists in the current scope.`);
        }

        return true;
    }

    if (instr.type === 'br_if') {
        body.push(INSTR.BR_IF);

        try {
            // Branch target (label depth)
            const labelIndex = getLabelIndex(instr.label, func);
            body.push(...encodeULEB128(labelIndex));
        } catch (err) {
            throw createError(instr, func, module, `Invalid conditional branch target: ${instr.label}. Make sure the label exists in the current scope.`);
        }

        return true;
    }

    if (instr.type === 'br_table') {
        // Generated by 
        body.push(INSTR.BR_TABLE);

        try {
            // Add the vector count of labels
            body.push(...encodeULEB128(instr.labels.length));

            // Add each label's depth
            for (const label of instr.labels) {
                const labelIndex = getLabelIndex(label, func);
                body.push(...encodeULEB128(labelIndex));
            }

            // Add the default label's depth
            const defaultLabelIndex = getLabelIndex(instr.defaultLabel, func);
            body.push(...encodeULEB128(defaultLabelIndex));
        } catch (err) {
            throw createError(instr, func, module, `Invalid branch table target: ${err.message}. Make sure all branch labels exist in the current scope.`);
        }

        return true;
    }

    return false; // No control flow instruction matched
}