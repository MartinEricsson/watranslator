import { encodeULEB128 } from "../compile-utils.mjs";

const ATOMIC_PREFIX = 0xFE;
const ATOMIC_I32_LOAD = 0x10;      // i32.atomic.load
const ATOMIC_I64_LOAD = 0x11;      // i64.atomic.load
const ATOMIC_I32_LOAD8_U = 0x12;   // i32.atomic.load8_u
const ATOMIC_I32_LOAD16_U = 0x13;  // i32.atomic.load16_u
const ATOMIC_I64_LOAD8_U = 0x14;   // i64.atomic.load8_u
const ATOMIC_I64_LOAD16_U = 0x15;  // i64.atomic.load16_u
const ATOMIC_I64_LOAD32_U = 0x16;  // i64.atomic.load32_u
const ATOMIC_I32_STORE = 0x17;     // i32.atomic.store
const ATOMIC_I64_STORE = 0x18;     // i64.atomic.store
const ATOMIC_I32_STORE8 = 0x19;    // i32.atomic.store8 (Generated by ðŸ¤–)
const ATOMIC_I32_STORE16 = 0x1A;   // i32.atomic.store16
const ATOMIC_I64_STORE8 = 0x1B;    // i64.atomic.store8
const ATOMIC_I64_STORE16 = 0x1C;   // i64.atomic.store16
const ATOMIC_I64_STORE32 = 0x1D;   // i64.atomic.store32

// Generated by ðŸ¤–
const ATOMIC_INSTR = new Map([
    ['i32.atomic.load', ATOMIC_I32_LOAD],
    ['i64.atomic.load', ATOMIC_I64_LOAD],
    ['i32.atomic.load8_u', ATOMIC_I32_LOAD8_U],
    ['i32.atomic.load16_u', ATOMIC_I32_LOAD16_U],
    ['i64.atomic.load8_u', ATOMIC_I64_LOAD8_U],
    ['i64.atomic.load16_u', ATOMIC_I64_LOAD16_U],
    ['i64.atomic.load32_u', ATOMIC_I64_LOAD32_U],
    ['i32.atomic.store', ATOMIC_I32_STORE],
    ['i32.atomic.store8', ATOMIC_I32_STORE8],
    ['i32.atomic.store16', ATOMIC_I32_STORE16],
    ['i64.atomic.store', ATOMIC_I64_STORE],
    ['i64.atomic.store8', ATOMIC_I64_STORE8],
    ['i64.atomic.store16', ATOMIC_I64_STORE16],
    ['i64.atomic.store32', ATOMIC_I64_STORE32],
]);

// Generated by ðŸ¤–
export function compileAtomicLoadStore(instr, func, body, module) {
    // Handle both instruction formats - some may use 'op' property and others may use 'type' property
    const instrType = instr.op || instr.type; // TODO: Fix this so we do not use both paths, or?

    if (!ATOMIC_INSTR.has(instrType)) {
        return false;
    }

    // Add atomic prefix (0xFE) for all atomic operations
    body.push(ATOMIC_PREFIX);

    // Get the specific opcode for this atomic operation
    const opcode = ATOMIC_INSTR.get(instrType);
    body.push(opcode);

    // Calculate the natural alignment based on the operation type
    let defaultAlign = 2; // Default for 32-bit (2^2 = 4 bytes)

    if (instrType.includes('8_') || instrType.includes('store8')) {
        defaultAlign = 0; // 8-bit operations (2^0 = 1 byte)
    } else if (instrType.includes('16_') || instrType.includes('store16')) {
        defaultAlign = 1; // 16-bit operations (2^1 = 2 bytes)
    } else if (instrType.includes('32_') || instrType.includes('store32')) {
        defaultAlign = 2; // 32-bit operations (2^2 = 4 bytes)
    } else if (instrType.startsWith('i64.') && !instrType.includes('_')) {
        defaultAlign = 3; // Full 64-bit operations (2^3 = 8 bytes)
    }

    // Encode memory alignment 
    const alignment = typeof instr.align === 'number' ? instr.align : defaultAlign;
    body.push(...encodeULEB128(alignment));

    // Encode memory offset
    const offset = typeof instr.offset === 'number' ? instr.offset : 0;
    body.push(...encodeULEB128(offset));

    return true;
}