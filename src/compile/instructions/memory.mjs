import wasmConstants from "../constants.mjs";
import { encodeULEB128 } from "../compile-utils.mjs";
import { createError } from "./error.mjs";

const {
    INSTR
} = wasmConstants;

// Generated by ðŸ¤–
function compileMemoryInit(body, instr) {
    // When memory.init is used stack-style, the values are:
    // [dest(i32), offset(i32), size(i32), segment_idx(i32)]
    // But WebAssembly expects them in a different order with different encoding

    // Pop segment index off the stack by adding a DROP instruction
    body.push(INSTR.DROP);

    // Add the actual memory.init operation with hardcoded indices
    body.push(INSTR.BULK_PREFIX);   // 0xFC prefix for bulk memory operations
    body.push(INSTR.MEMORY_INIT);   // 0x08 opcode for memory.init
    body.push(0x01);                // Data segment index (hardcoded to 1 for our passive segment)
    body.push(0x00);                // Memory index - must be 0 in the MVP
}

export function compileMemoryInstruction(instr, body, module) {
    if (instr.type === 'memory.size') {
        // Check if we have a memory reference for multiple memories
        if (instr.memoryRef !== null) {
            // Handle multi-memory size operation
            body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for extended operations
            body.push(0x08);               // opcode for multi-memory size

            // Determine memory index
            let memIndex = 0;
            if (typeof instr.memoryRef === 'string' && instr.memoryRef.startsWith('$')) {
                // Find memory by name
                const memory = module.memories.find(m => m.id === instr.memoryRef);
                if (!memory) {
                    throw createError(instr, null, module, `Unknown memory reference: ${instr.memoryRef}`);
                }
                memIndex = memory.index;
            } else if (typeof instr.memoryRef === 'number') {
                memIndex = instr.memoryRef;
            }

            body.push(...encodeULEB128(memIndex));
        } else {
            // Standard memory.size for default memory
            body.push(INSTR.MEMORY_SIZE);
            body.push(0x00); // Memory index 0 in single-memory mode
        }
        return true;
    }

    if (instr.type === 'memory.grow') {
        // Check if we have a memory reference for multiple memories
        if (instr.memoryRef !== null) {
            // Handle multi-memory grow operation
            body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for extended operations
            body.push(0x09);               // opcode for multi-memory grow

            // Determine memory index
            let memIndex = 0;
            if (typeof instr.memoryRef === 'string' && instr.memoryRef.startsWith('$')) {
                // Find memory by name
                const memory = module.memories.find(m => m.id === instr.memoryRef);
                if (!memory) {
                    throw createError(instr, null, module, `Unknown memory reference: ${instr.memoryRef}`);
                }
                memIndex = memory.index;
            } else if (typeof instr.memoryRef === 'number') {
                memIndex = instr.memoryRef;
            }

            body.push(...encodeULEB128(memIndex));
        } else {
            // Standard memory.grow for default memory
            body.push(INSTR.MEMORY_GROW);
            body.push(0x00); // Memory index 0 in single-memory mode
        }
        return true;
    }

    // Bulk memory operations
    if (instr.type === 'memory.fill') {
        // memory.fill is a bulk memory operation with prefix
        body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for bulk memory operations
        body.push(INSTR.MEMORY_FILL);  // 0x0B opcode for memory.fill
        body.push(0x00);               // Reserved value (memory index) - must be 0 in the MVP
        return true;
    }

    if (instr.type === 'memory.copy') {
        // memory.copy is a bulk memory operation with prefix
        body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for bulk memory operations
        body.push(INSTR.MEMORY_COPY);  // 0x0A opcode for memory.copy
        body.push(0x00);               // Destination memory index - must be 0 in the MVP
        body.push(0x00);               // Source memory index - must be 0 in the MVP
        return true;
    }

    if (instr.type === 'memory.init') {
        // Generated by ðŸ¤–
        // Use the helper function to generate memory.init instruction
        compileMemoryInit(body, instr);
        return true;
    }

    if (instr.type === 'data.drop') {
        // Generated by ðŸ¤–
        // Get the data segment index from the instruction or use the default
        const segmentIndex = 0; // Default segment index

        // Only drop from stack if no dataLabel is provided
        if (!instr.dataLabel) {
            // Pop segment index from the stack - this was pushed in the WAT file
            body.push(INSTR.DROP);
        }

        // Add the data.drop instruction
        body.push(INSTR.BULK_PREFIX);    // 0xFC prefix for bulk memory operations
        body.push(INSTR.DATA_DROP);      // 0x09 opcode for data.drop
        body.push(segmentIndex);         // Use the data segment index
        return true;
    }

    return false;
}