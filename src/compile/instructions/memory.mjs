import wasmConstants from "../constants.mjs";

const {
    INSTR
} = wasmConstants;

// Generated by ðŸ¤–
function compileMemoryInit(body, instr) {
    // When memory.init is used stack-style, the values are:
    // [dest(i32), offset(i32), size(i32), segment_idx(i32)]
    // But WebAssembly expects them in a different order with different encoding

    // Pop segment index off the stack by adding a DROP instruction
    body.push(INSTR.DROP);

    // Add the actual memory.init operation with hardcoded indices
    body.push(INSTR.BULK_PREFIX);   // 0xFC prefix for bulk memory operations
    body.push(INSTR.MEMORY_INIT);   // 0x08 opcode for memory.init
    body.push(0x01);                // Data segment index (hardcoded to 1 for our passive segment)
    body.push(0x00);                // Memory index - must be 0 in the MVP
}

export function compileMemoryInstruction(instr, body) {
    if (instr.type === 'memory.size') {
        body.push(INSTR.MEMORY_SIZE);
        body.push(0x00); // Reserved value - must be 0 in the current version
        return true;
    }
    else if (instr.type === 'memory.grow') {
        body.push(INSTR.MEMORY_GROW);
        body.push(0x00); // Reserved value - must be 0 in the current version
        return true;
    }
    // Bulk memory operations
    else if (instr.type === 'memory.fill') {
        // memory.fill is a bulk memory operation with prefix
        body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for bulk memory operations
        body.push(INSTR.MEMORY_FILL);  // 0x0B opcode for memory.fill
        body.push(0x00);               // Reserved value (memory index) - must be 0 in the MVP
        return true;
    }
    else if (instr.type === 'memory.copy') {
        // memory.copy is a bulk memory operation with prefix
        body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for bulk memory operations
        body.push(INSTR.MEMORY_COPY);  // 0x0A opcode for memory.copy
        body.push(0x00);               // Destination memory index - must be 0 in the MVP
        body.push(0x00);               // Source memory index - must be 0 in the MVP
        return true;
    }
    else if (instr.type === 'memory.init') {
        // Generated by ðŸ¤–
        // Use the helper function to generate memory.init instruction
        compileMemoryInit(body, instr);
        return true;
    } else if (instr.type === 'data.drop') {
        // Generated by ðŸ¤–
        // Get the data segment index from the instruction or use the default
        let segmentIndex = 0; // Default segment index
        
        // Only drop from stack if no dataLabel is provided
        if (!instr.dataLabel) {
            // Pop segment index from the stack - this was pushed in the WAT file
            body.push(INSTR.DROP);
        }

        // Add the data.drop instruction
        body.push(INSTR.BULK_PREFIX);    // 0xFC prefix for bulk memory operations
        body.push(INSTR.DATA_DROP);      // 0x09 opcode for data.drop
        body.push(segmentIndex);         // Use the data segment index
        return true;
    }

    return false;
}