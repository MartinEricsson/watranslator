import wasmConstants from "../constants.mjs";
import { encodeULEB128 } from "../compile-utils.mjs";
import { createError } from "./error.mjs";

const {
    INSTR
} = wasmConstants;

// Generated by ðŸ¤–
function compileMemoryInit(body, instr, module) {
    // For memory.init, the stack has: [dest, offset, size, segment_idx]
    // But the segment_idx is handled separately in binary format

    // We need to DROP the segment index from the stack since WebAssembly binary format
    // doesn't expect it there - it's encoded directly in the instruction
    body.push(INSTR.DROP);           // Remove segment index from stack

    // Add the memory.init instruction
    body.push(INSTR.BULK_PREFIX);    // 0xFC prefix for bulk memory operations
    body.push(INSTR.MEMORY_INIT);    // 0x08 opcode for memory.init
    body.push(0x01);                 // Data segment index (hardcoded to 1, the passive segment)
    body.push(0x00);                 // Memory index (0)
}

export function compileMemoryInstruction(instr, body, module) {
    if (instr.type === 'memory.size') {
        // Standard memory.size for default memory - no special handling needed
        body.push(INSTR.MEMORY_SIZE);
        body.push(0x00); // Memory index 0 in single-memory mode
        return true;
    }

    if (instr.type === 'memory.grow') {
        // Standard memory.grow for default memory - no special handling needed
        body.push(INSTR.MEMORY_GROW);
        body.push(0x00); // Memory index 0 in single-memory mode
        return true;
    }

    // Only process data-related bulk memory operations if we actually have data segments
    // This prevents invalid data segment index errors in modules without data segments
    const hasDataSegments = module && module.datas && module.datas.length > 0;

    // For operations that require data segments, skip them if there are none
    if (!hasDataSegments) {
        if (instr.type === 'memory.init' || instr.type === 'data.drop') {
            // Skip data-related operations when no data segments exist
            return true;
        }
    }

    // Handle memory operations that don't strictly need data segments
    if (instr.type === 'memory.fill') {
        // memory.fill is a bulk memory operation with prefix
        body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for bulk memory operations
        body.push(0x0B);               // 0x0B opcode for memory.fill
        body.push(0x00);               // Reserved value (memory index) - must be 0 in the MVP
        return true;
    }

    if (instr.type === 'memory.copy') {
        // memory.copy is a bulk memory operation with prefix
        body.push(INSTR.BULK_PREFIX);  // 0xFC prefix for bulk memory operations
        body.push(INSTR.MEMORY_COPY);  // 0x0A opcode for memory.copy
        body.push(0x00);               // Destination memory index - must be 0 in the MVP
        body.push(0x00);               // Source memory index - must be 0 in the MVP
        return true;
    }

    // Handle data segment operations only if we have data segments
    if (hasDataSegments) {
        if (instr.type === 'memory.init') {
            // Generated by ðŸ¤–
            compileMemoryInit(body, instr, module);
            return true;
        }

        if (instr.type === 'data.drop') {
            // Generated by ðŸ¤–
            // Check if it's a direct reference to a data segment or a stack value
            if (instr.dataLabel) {
                // Direct reference to a labeled data segment - no stack manipulation needed
                body.push(INSTR.BULK_PREFIX);    // 0xFC prefix for bulk memory operations
                body.push(INSTR.DATA_DROP);      // 0x09 opcode for data.drop

                // Find the index of the referenced data segment
                let segmentIndex = 0;
                if (module.datas) {
                    const dataSegment = module.datas.find(d => d.id === instr.dataLabel);
                    if (dataSegment) {
                        segmentIndex = module.datas.indexOf(dataSegment);
                    }
                }

                body.push(segmentIndex);         // Use the correct data segment index
            } else {
                // Stack-based data.drop - we need to drop the segment index from the stack
                body.push(INSTR.DROP);           // Remove segment index from stack

                // Add the data.drop instruction
                body.push(INSTR.BULK_PREFIX);    // 0xFC prefix for bulk memory operations
                body.push(INSTR.DATA_DROP);      // 0x09 opcode for data.drop
                body.push(0x01);                 // Use data segment index 1 (for passive segment)
            }
            return true;
        }
    }

    return false;
}