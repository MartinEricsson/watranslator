import { createError } from "./error.mjs";
import { encodeULEB128 } from "../compile-utils.mjs";

// Memory-related SIMD Instructions
const V128_LOAD = 0;               // v128.load
const V128_LOAD8X8_S = 1;          // v128.load8x8_s
const V128_LOAD8X8_U = 2;          // v128.load8x8_u
const V128_LOAD16X4_S = 3;         // v128.load16x4_s
const V128_LOAD16X4_U = 4;         // v128.load16x4_u
const V128_LOAD32X2_S = 5;         // v128.load32x2_s
const V128_LOAD32X2_U = 6;         // v128.load32x2_u
const V128_LOAD8_SPLAT = 7;        // v128.load8_splat
const V128_LOAD16_SPLAT = 8;       // v128.load16_splat
const V128_LOAD32_SPLAT = 9;       // v128.load32_splat
const V128_LOAD64_SPLAT = 10;      // v128.load64_splat
const V128_STORE = 11;             // v128.store
const V128_LOAD32_ZERO = 92;       // v128.load32_zero
const V128_LOAD64_ZERO = 93;       // v128.load64_zero
const V128_LOAD8_LANE = 84;        // v128.load8_lane
const V128_LOAD16_LANE = 85;       // v128.load16_lane
const V128_LOAD32_LANE = 86;       // v128.load32_lane
const V128_LOAD64_LANE = 87;       // v128.load64_lane
const V128_STORE8_LANE = 88;       // v128.store8_lane
const V128_STORE16_LANE = 89;      // v128.store16_lane
const V128_STORE32_LANE = 90;      // v128.store32_lane
const V128_STORE64_LANE = 91;      // v128.store64_lane
// Generated by 🤖

// SIMD constant for the prefix
const SIMD_PREFIX = 0xFD;

export function compileSIMDMemory(instruction, bytes) {
    const type = instruction.type;
    
    // Handle v128.load - basic 16-byte aligned vector load
    if (type === 'v128.load') {
        bytes.push(SIMD_PREFIX, V128_LOAD);
        
        // Use alignment from instruction, default to 0 if undefined
        const align = instruction.align !== undefined ? instruction.align : 0;
        bytes.push(...encodeULEB128(align));
        
        // Memory offset (defaults to 0)
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        
        return true;
    }
    // Generated by 🤖
    
    // Handle sign/zero-extending loads
    else if (type === 'v128.load8x8_s') {
        bytes.push(SIMD_PREFIX, V128_LOAD8X8_S);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    else if (type === 'v128.load8x8_u') {
        bytes.push(SIMD_PREFIX, V128_LOAD8X8_U);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    // Generated by 🤖
    else if (type === 'v128.load16x4_s') {
        bytes.push(SIMD_PREFIX, V128_LOAD16X4_S);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    else if (type === 'v128.load16x4_u') {
        bytes.push(SIMD_PREFIX, V128_LOAD16X4_U);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    // Generated by 🤖
    else if (type === 'v128.load32x2_s') {
        bytes.push(SIMD_PREFIX, V128_LOAD32X2_S);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    else if (type === 'v128.load32x2_u') {
        bytes.push(SIMD_PREFIX, V128_LOAD32X2_U);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    // Generated by 🤖
    
    // Handle splat loads (replicate a scalar across all lanes)
    else if (type === 'v128.load8_splat') {
        bytes.push(SIMD_PREFIX, V128_LOAD8_SPLAT);
        const align = instruction.align !== undefined ? instruction.align : 0;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    else if (type === 'v128.load16_splat') {
        bytes.push(SIMD_PREFIX, V128_LOAD16_SPLAT);
        const align = instruction.align !== undefined ? instruction.align : 1;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    // Generated by 🤖
    else if (type === 'v128.load32_splat') {
        bytes.push(SIMD_PREFIX, V128_LOAD32_SPLAT);
        const align = instruction.align !== undefined ? instruction.align : 2;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    else if (type === 'v128.load64_splat') {
        bytes.push(SIMD_PREFIX, V128_LOAD64_SPLAT);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    // Generated by 🤖
    
    // Handle v128.store
    else if (type === 'v128.store') {
        bytes.push(SIMD_PREFIX, V128_STORE);
        const align = instruction.align !== undefined ? instruction.align : 4;
        bytes.push(...encodeULEB128(align));
        const offset = instruction.offset !== undefined ? instruction.offset : 0;
        bytes.push(...encodeULEB128(offset));
        return true;
    }
    // Generated by 🤖
    
    // Handle zero-extending loads
    else if (type === 'v128.load32_zero') {
        bytes.push(SIMD_PREFIX, V128_LOAD32_ZERO);
        const align = instruction.align !== undefined ? instruction.align : 2;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        return true;
    }
    else if (type === 'v128.load64_zero') {
        bytes.push(SIMD_PREFIX, V128_LOAD64_ZERO);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        return true;
    }
    
    // Handle lane-based loads
    else if (type === 'v128.load8_lane') {
        bytes.push(SIMD_PREFIX, V128_LOAD8_LANE);
        const align = instruction.align !== undefined ? instruction.align : 0;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-15)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 15) {
            throw createError(instruction, null, null, 'v128.load8_lane requires lane index 0-15');
        }
        bytes.push(laneIndex);
        return true;
    }
    else if (type === 'v128.load16_lane') {
        bytes.push(SIMD_PREFIX, V128_LOAD16_LANE);
        const align = instruction.align !== undefined ? instruction.align : 1;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-7)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 7) {
            throw createError(instruction, null, null, 'v128.load16_lane requires lane index 0-7');
        }
        bytes.push(laneIndex);
        return true;
    }
    else if (type === 'v128.load32_lane') {
        bytes.push(SIMD_PREFIX, V128_LOAD32_LANE);
        const align = instruction.align !== undefined ? instruction.align : 2;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-3)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 3) {
            throw createError(instruction, null, null, 'v128.load32_lane requires lane index 0-3');
        }
        bytes.push(laneIndex);
        return true;
    }
    else if (type === 'v128.load64_lane') {
        bytes.push(SIMD_PREFIX, V128_LOAD64_LANE);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-1)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 1) {
            throw createError(instruction, null, null, 'v128.load64_lane requires lane index 0-1');
        }
        bytes.push(laneIndex);
        return true;
    }
    
    // Handle lane-based stores
    else if (type === 'v128.store8_lane') {
        bytes.push(SIMD_PREFIX, V128_STORE8_LANE);
        const align = instruction.align !== undefined ? instruction.align : 0;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-15)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 15) {
            throw createError(instruction, null, null, 'v128.store8_lane requires lane index 0-15');
        }
        bytes.push(laneIndex);
        return true;
    }
    else if (type === 'v128.store16_lane') {
        bytes.push(SIMD_PREFIX, V128_STORE16_LANE);
        const align = instruction.align !== undefined ? instruction.align : 1;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-7)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 7) {
            throw createError(instruction, null, null, 'v128.store16_lane requires lane index 0-7');
        }
        bytes.push(laneIndex);
        return true;
    }
    else if (type === 'v128.store32_lane') {
        bytes.push(SIMD_PREFIX, V128_STORE32_LANE);
        const align = instruction.align !== undefined ? instruction.align : 2;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-3)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 3) {
            throw createError(instruction, null, null, 'v128.store32_lane requires lane index 0-3');
        }
        bytes.push(laneIndex);
        return true;
    }
    else if (type === 'v128.store64_lane') {
        bytes.push(SIMD_PREFIX, V128_STORE64_LANE);
        const align = instruction.align !== undefined ? instruction.align : 3;
        bytes.push(...encodeULEB128(align));
        bytes.push(...encodeULEB128(instruction.offset || 0));
        
        // Add the lane index (0-1)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 1) {
            throw createError(instruction, null, null, 'v128.store64_lane requires lane index 0-1');
        }
        bytes.push(laneIndex);
        return true;
    }

    return false;
}
// Generated by 🤖