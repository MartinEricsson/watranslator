import { createError } from "./error.mjs";
import { encodeF32, encodeF64 } from "../compile-utils.mjs";

// SIMD Instructions (v128)
const SIMD_PREFIX = 0xFD;
const V128_CONST = 12;             // v128.const
const I8X16_SHUFFLE = 13;          // i8x16.shuffle

// Lane-based SIMD Instructions
const I8X16_EXTRACT_LANE_S = 21;   // i8x16.extract_lane_s
const I8X16_EXTRACT_LANE_U = 22;   // i8x16.extract_lane_u
const I8X16_REPLACE_LANE = 23;     // i8x16.replace_lane
const I16X8_EXTRACT_LANE_S = 24;   // i16x8.extract_lane_s
const I16X8_EXTRACT_LANE_U = 25;   // i16x8.extract_lane_u
const I16X8_REPLACE_LANE = 26;     // i16x8.replace_lane
const I32X4_EXTRACT_LANE = 27;     // i32x4.extract_lane
const I32X4_REPLACE_LANE = 28;     // i32x4.replace_lane
const I64X2_EXTRACT_LANE = 29;     // i64x2.extract_lane
const I64X2_REPLACE_LANE = 30;     // i64x2.replace_lane
const F32X4_EXTRACT_LANE = 31;     // f32x4.extract_lane
const F32X4_REPLACE_LANE = 32;     // f32x4.replace_lane
const F64X2_EXTRACT_LANE = 33;     // f64x2.extract_lane
const F64X2_REPLACE_LANE = 34;     // f64x2.replace_lane

export function compileSIMDLaneBased(instruction, bytes) {
    const opcode = instruction.opcode;

    if (opcode === 'v128.const') {
        // v128.const instruction (16 bytes / 128 bits constant)
        bytes.push(SIMD_PREFIX);
        bytes.push(V128_CONST);

        // Get the shape and immediate values
        const shape = instruction.shape || 'i8x16';
        const immediates = instruction.immediates || [];

        // Validate based on shape
        const expectedValues = {
            'i8x16': 16,
            'i16x8': 8,
            'i32x4': 4,
            'i64x2': 2,
            'f32x4': 4,
            'f64x2': 2
        }[shape] || 16;

        if (immediates.length !== expectedValues) {
            throw createError(instruction, null, null, `v128.const with shape ${shape} requires exactly ${expectedValues} values`);
        }

        // Add all 16 bytes to the output based on the shape
        if (shape === 'i8x16') {
            // Each value is 1 byte
            for (let i = 0; i < 16; i++) {
                bytes.push(immediates[i] & 0xFF);
            }
        } else if (shape === 'i16x8') {
            // Each value is 2 bytes
            for (let i = 0; i < 8; i++) {
                const value = immediates[i];
                bytes.push(value & 0xFF);          // Low byte
                bytes.push((value >> 8) & 0xFF);   // High byte
            }
        } else if (shape === 'i32x4') {
            // Each value is 4 bytes (integer format)
            for (let i = 0; i < 4; i++) {
                const value = immediates[i];
                bytes.push(value & 0xFF);          // First byte
                bytes.push((value >> 8) & 0xFF);   // Second byte
                bytes.push((value >> 16) & 0xFF);  // Third byte
                bytes.push((value >> 24) & 0xFF);  // Fourth byte
            }
        } else if (shape === 'f32x4') {
            // Each value is 4 bytes (IEEE 754 float format)
            for (let i = 0; i < 4; i++) {
                const encodedFloat = encodeF32(immediates[i]);
                bytes.push(...encodedFloat);       // Use IEEE 754 encoding
            } // Generated by 
        } else if (shape === 'i64x2') {
            // Each value is 8 bytes - handling all 64 bits properly
            const buffer = new ArrayBuffer(8); // Generated by 
            const view = new DataView(buffer); // Generated by 
            for (let i = 0; i < 2; i++) {
                let value = immediates[i];
                
                // Convert to BigInt for proper 64-bit handling
                if (typeof value !== 'bigint') {
                    value = BigInt(value);
                }
                
                // Use DataView to get little-endian bytes // Generated by 
                view.setBigInt64(0, value, true); // true for little-endian // Generated by 
                
                // Push all 8 bytes
                for (let b = 0; b < 8; b++) { // Generated by 
                    bytes.push(view.getUint8(b)); // Generated by 
                } // Generated by 
            } // Generated by 
        } else if (shape === 'f64x2') {
            // Each value is 8 bytes (IEEE 754 double format)
            for (let i = 0; i < 2; i++) {
                const encodedDouble = encodeF64(immediates[i]);
                bytes.push(...encodedDouble);      // Use IEEE 754 encoding
            } // Generated by 
        }

        return true; // Successfully handled instruction
    }

    if (opcode === 'i8x16.shuffle') {
        // i8x16.shuffle instruction
        bytes.push(SIMD_PREFIX);
        bytes.push(I8X16_SHUFFLE);

        // Get the 16 lane indices (values must be 0-31)
        const laneIndices = instruction.laneIndices || [];
        if (laneIndices.length !== 16) {
            throw createError(instruction, null, null, 'i8x16.shuffle requires exactly 16 lane indices');
        }

        // Add all 16 lane indices to the output
        for (let i = 0; i < 16; i++) {
            const index = laneIndices[i];
            if (index < 0 || index > 31) {
                throw createError(instruction, null, null, 'i8x16.shuffle lane indices must be 0-31');
            }
            bytes.push(index & 0xFF);
        }

        return true; // Successfully handled instruction
    } // Generated by 

    if (opcode === 'i8x16.extract_lane_u') {
        // i8x16.extract_lane_u instruction
        bytes.push(SIMD_PREFIX, I8X16_EXTRACT_LANE_U);

        // Add the lane index (0-15)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 15) {
            throw createError(instruction, null, null, 'i8x16.extract_lane_u requires lane index 0-15');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i8x16.extract_lane_s') {
        // i8x16.extract_lane_s instruction
        bytes.push(SIMD_PREFIX, I8X16_EXTRACT_LANE_S);

        // Add the lane index (0-15)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 15) {
            throw createError(instruction, null, null, 'i8x16.extract_lane_s requires lane index 0-15');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i8x16.replace_lane') {
        // i8x16.replace_lane instruction
        bytes.push(SIMD_PREFIX, I8X16_REPLACE_LANE);

        // Add the lane index (0-15)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 15) {
            throw createError(instruction, null, null, 'i8x16.replace_lane requires lane index 0-15');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i16x8.extract_lane_s') {
        // i16x8.extract_lane_s instruction
        bytes.push(SIMD_PREFIX, I16X8_EXTRACT_LANE_S);

        // Add the lane index (0-7)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 7) {
            throw createError(instruction, null, null, 'i16x8.extract_lane_s requires lane index 0-7');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i16x8.extract_lane_u') {
        // i16x8.extract_lane_u instruction
        bytes.push(SIMD_PREFIX, I16X8_EXTRACT_LANE_U);

        // Add the lane index (0-7)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 7) {
            throw createError(instruction, null, null, 'i16x8.extract_lane_u requires lane index 0-7');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i16x8.replace_lane') {
        // i16x8.replace_lane instruction
        bytes.push(SIMD_PREFIX, I16X8_REPLACE_LANE);

        // Add the lane index (0-7)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 7) {
            throw createError(instruction, null, null, 'i16x8.replace_lane requires lane index 0-7');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i32x4.extract_lane') {
        // i32x4.extract_lane instruction
        bytes.push(SIMD_PREFIX, I32X4_EXTRACT_LANE);

        // Add the lane index (0-3)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 3) {
            throw createError(instruction, null, null, 'i32x4.extract_lane requires lane index 0-3');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i32x4.replace_lane') {
        // i32x4.replace_lane instruction
        bytes.push(SIMD_PREFIX, I32X4_REPLACE_LANE);

        // Add the lane index (0-3)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 3) {
            throw createError(instruction, null, null, 'i32x4.replace_lane requires lane index 0-3');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i64x2.extract_lane') {
        // i64x2.extract_lane instruction
        bytes.push(SIMD_PREFIX, I64X2_EXTRACT_LANE);

        // Add the lane index (0-1)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 1) {
            throw createError(instruction, null, null, 'i64x2.extract_lane requires lane index 0-1');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'i64x2.replace_lane') {
        // i64x2.replace_lane instruction
        bytes.push(SIMD_PREFIX, I64X2_REPLACE_LANE);

        // Add the lane index (0-1)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 1) {
            throw createError(instruction, null, null, 'i64x2.replace_lane requires lane index 0-1');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'f32x4.extract_lane') {
        // f32x4.extract_lane instruction
        bytes.push(SIMD_PREFIX, F32X4_EXTRACT_LANE);

        // Add the lane index (0-3)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 3) {
            throw createError(instruction, null, null, 'f32x4.extract_lane requires lane index 0-3');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'f32x4.replace_lane') {
        // f32x4.replace_lane instruction
        bytes.push(SIMD_PREFIX, F32X4_REPLACE_LANE);

        // Add the lane index (0-3)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 3) {
            throw createError(instruction, null, null, 'f32x4.replace_lane requires lane index 0-3');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'f64x2.extract_lane') {
        // f64x2.extract_lane instruction
        bytes.push(SIMD_PREFIX, F64X2_EXTRACT_LANE);

        // Add the lane index (0-1)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 1) {
            throw createError(instruction, null, null, 'f64x2.extract_lane requires lane index 0-1');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    if (opcode === 'f64x2.replace_lane') {
        // f64x2.replace_lane instruction
        bytes.push(SIMD_PREFIX, F64X2_REPLACE_LANE);

        // Add the lane index (0-1)
        const laneIndex = instruction.laneIndex;
        if (laneIndex === undefined || laneIndex < 0 || laneIndex > 1) {
            throw createError(instruction, null, null, 'f64x2.replace_lane requires lane index 0-1');
        }

        bytes.push(laneIndex);
        return true;
    } // Generated by 

    return false; // Instruction not handled
} // Generated by 