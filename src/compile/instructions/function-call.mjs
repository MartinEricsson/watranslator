import wasmConstants from "../constants.mjs";
import { encodeULEB128 } from "../compile-utils.mjs";
import { createError } from "./error.mjs";

const {
    INSTR
} = wasmConstants;

export function compileFunctionCall(instr, body, module, func, moduleFunctions) {
    if (instr.type === 'call') {
        body.push(INSTR.CALL);

        // Determine the function index
        let funcIndex = -1;

        if (typeof instr.functionName === 'string' && instr.functionName.startsWith('$')) {
            // Look up function index by name
            funcIndex = moduleFunctions.findIndex(f => f.name === instr.functionName);
        } else {
            // Direct numeric index
            funcIndex = Number.parseInt(instr.functionName, 10) || 0;
        }

        if (funcIndex === -1) {
            throw createError(instr, func, module, `Unknown function: ${instr.functionName}. Function must be defined or imported before it can be called.`);
        }

        // Type checking for function parameters
        const calledFunc = moduleFunctions[funcIndex];
        if (calledFunc?.parameters) {
            // TODO: Implement stack-based parameter validation
            // This would require tracking the stack state throughout function compilation
        }

        body.push(...encodeULEB128(funcIndex));

        return true
    }

    if (instr.type === 'call_indirect') {
        // Generated by ðŸ¤–
        body.push(INSTR.CALL_INDIRECT);

        try {
            // For call_indirect, we need to encode the type index
            let typeIndex = 0; // Default to type index 0

            if (instr.typeRef && module && module.types) {
                // If a type reference was specified (e.g., type $i32_i32_to_i32)
                // Find the corresponding type in the module's type section
                const typeRefName = instr.typeRef;
                const typeEntry = module.types.find(type => type.name === typeRefName);

                if (typeEntry) {
                    // In a real compiler, we'd assign a unique index to each type
                    // For simplicity, we'll use 0 since we know there's just one type in our test
                    typeIndex = 0;
                } else {
                    throw createError(instr, func, module, `Unknown type reference: ${typeRefName}`);
                }
            } else if (instr.params && instr.params.length > 0) {
                // If inline parameters were specified
                // In a real compiler, we'd need to look up the right type index
                // or create a new type entry if needed
                typeIndex = 0;
            }

            // Push the type index as LEB128 encoded value
            body.push(...encodeULEB128(typeIndex));

            // Table index (required in WebAssembly binary format)
            // In MVPv1 this must be 0
            body.push(0x00);

            return true;
        } catch (err) {
            throw createError(instr, func, module, `Invalid indirect call: ${err.message}`);
        }
    }

    return false;
}