import { createError } from './error.mjs';
import { compileVariableAccess } from './variable-access.mjs';
import { compileVariableConstants } from './variable-constants.mjs';
import { compileStackInstruction } from './stack-instruction.mjs';
import { compileTableInstruction } from './table.mjs';
import { compileMemoryInstruction } from './memory.mjs';
import { compileMemoryAccess } from './memory-access.mjs';
import { compileFunctionCall } from './function-call.mjs';
import { compileControlFlow } from './control-flow.mjs';
import { compileReferenceOpcodes } from './reference-operation.mjs';
import { compileAtomicLoadStore } from './atomic-load-store.mjs';
import { compileAtomicWaitNotify } from './atomic-wait-notify.mjs';
import { compileAtomicOps } from './atomic-ops.mjs';
import { compileNonTrappingFloatToInt } from './non-trapping-float-to-int.mjs';
import { compileSIMDLaneBased } from './simd-lane-based.mjs';
import { compileSIMDMemory } from './simd-memory.mjs';
import { compileSIMDPlainOpcode } from './simd-plain-opcode.mjs'; // Generated by ðŸ¤–

export function compileInstruction(instr, func, body, moduleFunctions, moduleGlobals, module) {
    if (compileVariableAccess(instr, func, body, moduleGlobals, module)) {
        return;
    }

    if (compileVariableConstants(instr, body)) {
        return;
    }

    if (compileControlFlow(instr, func, body, moduleFunctions, moduleGlobals, module)) {
        return;
    }

    if (compileStackInstruction(instr, body)) {
        return;
    }

    if (compileMemoryAccess(instr, func, body, module)) {
        return;
    }

    if (compileMemoryInstruction(instr, body, module)) {
        return;
    }

    if (compileFunctionCall(instr, body, module, func, moduleFunctions)) {
        return;
    }

    if (compileTableInstruction(instr, func, module, body)) {
        return;
    }

    if (compileReferenceOpcodes(instr, func, module, body)) {
        return;
    }

    if (compileAtomicLoadStore(instr, func, body, module)) {
        return;
    }

    if (compileAtomicWaitNotify(instr, func, body, module)) {
        return;
    }

    if (compileAtomicOps(instr, func, body, module)) {
        return;
    }

    if (compileSIMDLaneBased(instr, body)) {
        return;
    }

    if (compileNonTrappingFloatToInt(instr, body)) {
        return;
    }

    if (compileSIMDMemory(instr, body)) {
        return;
    }

    if (compileSIMDPlainOpcode(instr, body)) { // Generated by ðŸ¤–
        return;
    }

    throw createError(instr, func, module, `Unsupported instruction type: ${instr.type || instr.op}. Check for typos or refer to the WebAssembly specification.`);
}