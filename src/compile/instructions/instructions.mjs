import { createError } from './error.mjs';
import { compileVariableAccess } from './variable-access.mjs';
import { compileVariableConstants } from './variable-constants.mjs';
import { compileStackInstruction } from './stack-instruction.mjs';
import { compileTableInstruction } from './table.mjs';
import { compileMemoryInstruction } from './memory.mjs';
import { compileMemoryAccess } from './memory-access.mjs';
import { compileFunctionCall } from './function-call.mjs';
import { compileControlFlow } from './control-flow.mjs';
import { compileReferenceOpcodes } from './reference-operation.mjs';
import { compileAtomicLoadStore } from './atomic-load-store.mjs';
import { compileAtomicWaitNotify } from './atomic-wait-notify.mjs';
import { compileAtomicOps } from './atomic-ops.mjs';
import { compileNonTrappingFloatToInt } from './non-trapping-float-to-int.mjs';
import { compileSIMDLaneBased } from './simd-lane-based.mjs';
import { compileSIMDMemory } from './simd-memory.mjs';
import { compileSIMDPlainOpcode } from './simd-plain-opcode.mjs'; // Generated by ðŸ¤–

export function compileInstruction(instr, func, body, moduleFunctions, moduleGlobals, module) {
    if (compileVariableAccess(instr, func, body, moduleGlobals, module)) {
        return;
    } else if (compileVariableConstants(instr, body)) {
        return;
    } else if (compileControlFlow(instr, func, body, moduleFunctions, moduleGlobals, module)) {
        return;
    } else if (compileStackInstruction(instr, body)) {
        return;
    } else if (compileMemoryAccess(instr, func, body, module)) {
        return;
    } else if (compileMemoryInstruction(instr, body)) {
        return;
    } else if (compileFunctionCall(instr, body, module, func, moduleFunctions)) {
        return;
    } else if (compileTableInstruction(instr, func, module, body)) {
        return;
    } else if (compileReferenceOpcodes(instr, func, module, body)) {
        return;
    } else if (compileAtomicLoadStore(instr, func, body, module)) {
        return;
    } else if (compileAtomicWaitNotify(instr, func, body, module)) {
        return;
    } else if (compileAtomicOps(instr, func, body, module)) {
        return;
    } else if (compileSIMDLaneBased(instr, body)) {
        return;
    } else if (compileNonTrappingFloatToInt(instr, body)) {
        return;
    } else if (compileSIMDMemory(instr, body)) {
        return;
    } else if (compileSIMDPlainOpcode(instr, body)) { // Generated by ðŸ¤–
        return;
    } else {
        throw createError(instr, func, module, `Unsupported instruction type: ${instr.type || instr.op}. Check for typos or refer to the WebAssembly specification.`);
    }
}