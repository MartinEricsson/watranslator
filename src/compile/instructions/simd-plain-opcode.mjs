import { encodeULEB128 } from "../compile-utils.mjs";

// SIMD prefix common to all SIMD instructions
const SIMD_PREFIX = 0xFD;

// SIMD plain opcodes
// Generated by ðŸ¤–
const SIMD_OPCODES = new Map([
    // Swizzle, splat instructions
    ["i8x16.swizzle", 14],
    ["i8x16.splat", 15],
    ["i16x8.splat", 16],
    ["i32x4.splat", 17],
    ["i64x2.splat", 18],
    ["f32x4.splat", 19],
    ["f64x2.splat", 20],
    
    // Equality/comparison instructions for i8x16
    ["i8x16.eq", 35],
    ["i8x16.ne", 36],
    ["i8x16.lt_s", 37],
    ["i8x16.lt_u", 38],
    ["i8x16.gt_s", 39],
    ["i8x16.gt_u", 40],
    ["i8x16.le_s", 41],
    ["i8x16.le_u", 42],
    ["i8x16.ge_s", 43],
    ["i8x16.ge_u", 44],
    
    // Equality/comparison instructions for i16x8
    ["i16x8.eq", 45],
    ["i16x8.ne", 46],
    ["i16x8.lt_s", 47],
    ["i16x8.lt_u", 48],
    ["i16x8.gt_s", 49],
    ["i16x8.gt_u", 50],
    ["i16x8.le_s", 51],
    ["i16x8.le_u", 52],
    ["i16x8.ge_s", 53],
    ["i16x8.ge_u", 54],
    
    // Equality/comparison instructions for i32x4
    ["i32x4.eq", 55],
    ["i32x4.ne", 56],
    ["i32x4.lt_s", 57],
    ["i32x4.lt_u", 58],
    ["i32x4.gt_s", 59],
    ["i32x4.gt_u", 60],
    ["i32x4.le_s", 61],
    ["i32x4.le_u", 62],
    ["i32x4.ge_s", 63],
    ["i32x4.ge_u", 64],
    
    // Equality/comparison instructions for i64x2
    ["i64x2.eq", 214],
    ["i64x2.ne", 215],
    ["i64x2.lt_s", 216],
    ["i64x2.gt_s", 217],
    ["i64x2.le_s", 218],
    ["i64x2.ge_s", 219],
    
    // Equality/comparison instructions for f32x4
    ["f32x4.eq", 65],
    ["f32x4.ne", 66],
    ["f32x4.lt", 67],
    ["f32x4.gt", 68],
    ["f32x4.le", 69],
    ["f32x4.ge", 70],
    
    // Equality/comparison instructions for f64x2
    ["f64x2.eq", 71],
    ["f64x2.ne", 72],
    ["f64x2.lt", 73],
    ["f64x2.gt", 74],
    ["f64x2.le", 75],
    ["f64x2.ge", 76],
    
    // Vector operations
    ["v128.not", 77],
    ["v128.and", 78],
    ["v128.andnot", 79],
    ["v128.or", 80],
    ["v128.xor", 81],
    ["v128.bitselect", 82],
    ["v128.any_true", 83],
    
    // i8x16 operations
    ["i8x16.abs", 96],
    ["i8x16.neg", 97],
    ["i8x16.popcnt", 98],
    ["i8x16.all_true", 99],
    ["i8x16.bitmask", 100],
    ["i8x16.narrow_i16x8_s", 101],
    ["i8x16.narrow_i16x8_u", 102],
    ["i8x16.shl", 107],
    ["i8x16.shr_s", 108],
    ["i8x16.shr_u", 109],
    ["i8x16.add", 110],
    ["i8x16.add_sat_s", 111],
    ["i8x16.add_sat_u", 112],
    ["i8x16.sub", 113],
    ["i8x16.sub_sat_s", 114],
    ["i8x16.sub_sat_u", 115],
    ["i8x16.min_s", 118],
    ["i8x16.min_u", 119],
    ["i8x16.max_s", 120],
    ["i8x16.max_u", 121],
    ["i8x16.avgr_u", 123],
    
    // i16x8 operations
    ["i16x8.extadd_pairwise_i8x16_s", 124],
    ["i16x8.extadd_pairwise_i8x16_u", 125],
    ["i16x8.abs", 128],
    ["i16x8.neg", 129],
    ["i16x8.q15mulr_sat_s", 130],
    ["i16x8.all_true", 131],
    ["i16x8.bitmask", 132],
    ["i16x8.narrow_i32x4_s", 133],
    ["i16x8.narrow_i32x4_u", 134],
    ["i16x8.extend_low_i8x16_s", 135],
    ["i16x8.extend_high_i8x16_s", 136],
    ["i16x8.extend_low_i8x16_u", 137],
    ["i16x8.extend_high_i8x16_u", 138],
    ["i16x8.shl", 139],
    ["i16x8.shr_s", 140],
    ["i16x8.shr_u", 141],
    ["i16x8.add", 142],
    ["i16x8.add_sat_s", 143],
    ["i16x8.add_sat_u", 144],
    ["i16x8.sub", 145],
    ["i16x8.sub_sat_s", 146],
    ["i16x8.sub_sat_u", 147],
    ["i16x8.mul", 149],
    ["i16x8.min_s", 150],
    ["i16x8.min_u", 151],
    ["i16x8.max_s", 152],
    ["i16x8.max_u", 153],
    ["i16x8.avgr_u", 155],
    ["i16x8.extmul_low_i8x16_s", 156],
    ["i16x8.extmul_high_i8x16_s", 157],
    ["i16x8.extmul_low_i8x16_u", 158],
    ["i16x8.extmul_high_i8x16_u", 159],
  
    // i32x4 operations
    ["i32x4.extadd_pairwise_i16x8_s", 126],
    ["i32x4.extadd_pairwise_i16x8_u", 127],
    ["i32x4.abs", 160],
    ["i32x4.neg", 161],
    ["i32x4.all_true", 163],
    ["i32x4.bitmask", 164],
    ["i32x4.extend_low_i16x8_s", 167],
    ["i32x4.extend_high_i16x8_s", 168],
    ["i32x4.extend_low_i16x8_u", 169],
    ["i32x4.extend_high_i16x8_u", 170],
    ["i32x4.shl", 171],
    ["i32x4.shr_s", 172],
    ["i32x4.shr_u", 173],
    ["i32x4.add", 174],
    ["i32x4.sub", 177],
    ["i32x4.mul", 181],
    ["i32x4.min_s", 182],
    ["i32x4.min_u", 183],
    ["i32x4.max_s", 184],
    ["i32x4.max_u", 185],
    ["i32x4.dot_i16x8_s", 186],
    ["i32x4.extmul_low_i16x8_s", 188],
    ["i32x4.extmul_high_i16x8_s", 189],
    ["i32x4.extmul_low_i16x8_u", 190],
    ["i32x4.extmul_high_i16x8_u", 191],
    
    // i64x2 operations
    ["i64x2.abs", 192],
    ["i64x2.neg", 193],
    ["i64x2.all_true", 195],
    ["i64x2.bitmask", 196],
    ["i64x2.extend_low_i32x4_s", 199],
    ["i64x2.extend_high_i32x4_s", 200],
    ["i64x2.extend_low_i32x4_u", 201],
    ["i64x2.extend_high_i32x4_u", 202],
    ["i64x2.shl", 203],
    ["i64x2.shr_s", 204],
    ["i64x2.shr_u", 205],
    ["i64x2.add", 206],
    ["i64x2.sub", 209],
    ["i64x2.mul", 213],
    ["i64x2.extmul_low_i32x4_s", 220],
    ["i64x2.extmul_high_i32x4_s", 221],
    ["i64x2.extmul_low_i32x4_u", 222],
    ["i64x2.extmul_high_i32x4_u", 223],
    
    // f32x4 operations
    ["f32x4.ceil", 103],
    ["f32x4.floor", 104],
    ["f32x4.trunc", 105],
    ["f32x4.nearest", 106],
    ["f32x4.abs", 224],
    ["f32x4.neg", 225],
    ["f32x4.sqrt", 227],
    ["f32x4.add", 228],
    ["f32x4.sub", 229],
    ["f32x4.mul", 230],
    ["f32x4.div", 231],
    ["f32x4.min", 232],
    ["f32x4.max", 233],
    ["f32x4.pmin", 234],
    ["f32x4.pmax", 235],
    
    // f64x2 operations
    ["f64x2.ceil", 116],
    ["f64x2.floor", 117],
    ["f64x2.trunc", 122],
    ["f64x2.nearest", 148],
    ["f64x2.abs", 236],
    ["f64x2.neg", 237],
    ["f64x2.sqrt", 239],
    ["f64x2.add", 240],
    ["f64x2.sub", 241],
    ["f64x2.mul", 242],
    ["f64x2.div", 243],
    ["f64x2.min", 244],
    ["f64x2.max", 245],
    ["f64x2.pmin", 246],
    ["f64x2.pmax", 247],
    
    // Conversion operations
    ["i32x4.trunc_sat_f32x4_s", 248],
    ["i32x4.trunc_sat_f32x4_u", 249],
    ["f32x4.convert_i32x4_s", 250],
    ["f32x4.convert_i32x4_u", 251],
    ["i32x4.trunc_sat_f64x2_s_zero", 252],
    ["i32x4.trunc_sat_f64x2_u_zero", 253],
    ["f64x2.convert_low_i32x4_s", 254],
    ["f64x2.convert_low_i32x4_u", 255],
    ["f32x4.demote_f64x2_zero", 94],
    ["f64x2.promote_low_f32x4", 95]
]);

/**
 * Compiles SIMD plain opcode instructions.
 * 
 * @param {Object} instruction - The instruction object.
 * @param {Array} bytes - The byte array to which compiled code is appended.
 * @returns {boolean} - True if the instruction was handled, false otherwise.
 */
export function compileSIMDPlainOpcode(instruction, bytes) {
    const opcode = instruction.type;
    
    if (!SIMD_OPCODES.has(opcode)) {
        return false;
    }
    
    // Add SIMD prefix and the specific instruction opcode
    bytes.push(SIMD_PREFIX);
    bytes.push(...encodeULEB128(SIMD_OPCODES.get(opcode)));
    
    return true;
} // Generated by ðŸ¤–