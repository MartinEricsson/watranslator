import { peekToken, skipToken, atEnd, getCurrentCursor, getToken } from './tape.mjs';
import { isLabel } from './parse-util.mjs';
import { parseMemoryOpsInstruction } from './instruction/parse-memory-ops-instruction.mjs';
import { parseTableInstruction } from './instruction/parse-table-instruction.mjs';
import { parseAtomicRMWInstruction } from './instruction/parse-atomic-rmw-instruction.mjs';
import { parseRefInstruction } from './instruction/parse-ref-instruction.mjs';
import { parseAtomicsOpInstruction } from './instruction/parse-atomics-op-instruction.mjs';
import { parseSIMDLaneBased } from './instruction/parse-simd-lane-based.mjs';
import { parseSIMDMemory } from './instruction/parse-simd-memory.mjs';
import { parseSIMDPlainOpcode } from './instruction/parse-simd-plain-opcode.mjs';

const stackInstructions = [
    // Value types that might appear as standalone tokens in multi-value returns
    'i32', 'i64', 'f32', 'f64', 'v128', 'funcref',

    // Memory and table operations
    'memory.fill', 'memory.copy', 'memory.init', 'memory.size', 'memory.grow',
    'elem.drop', 'table.init', 'table.drop', 'table.copy',

    // Atomic operations
    'memory.atomic.notify', 'memory.atomic.wait32', 'memory.atomic.wait64',
    'i32.atomic.load', 'i32.atomic.load8_u', 'i32.atomic.load16_u',
    'i64.atomic.load', 'i64.atomic.load8_u', 'i64.atomic.load16_u', 'i64.atomic.load32_u',
    'i32.atomic.store', 'i32.atomic.store8', 'i32.atomic.store16',
    'i64.atomic.store', 'i64.atomic.store8', 'i64.atomic.store16', 'i64.atomic.store32',
    'i32.atomic.rmw.add', 'i64.atomic.rmw.add',
    'i32.atomic.rmw.sub', 'i64.atomic.rmw.sub',
    'i32.atomic.rmw.and', 'i64.atomic.rmw.and',
    'i32.atomic.rmw.or', 'i64.atomic.rmw.or',
    'i32.atomic.rmw.xor', 'i64.atomic.rmw.xor',
    'i32.atomic.rmw.xchg', 'i64.atomic.rmw.xchg',
    'i32.atomic.rmw.cmpxchg', 'i64.atomic.rmw.cmpxchg',
    'atomic.fence', // Generated by ðŸ¤–

    // i32 instructions
    'nop', 'return', 'drop', 'unreachable',
    'i32.add', 'i32.sub', 'i32.mul', 'i32.div_s', 'i32.div_u',
    'i32.rem_s', 'i32.rem_u', 'i32.and', 'i32.or', 'i32.xor',
    'i32.shl', 'i32.shr_s', 'i32.shr_u', 'i32.rotl', 'i32.rotr',
    'i32.eq', 'i32.ne', 'i32.lt_s', 'i32.lt_u', 'i32.gt_s',
    'i32.gt_u', 'i32.le_s', 'i32.le_u', 'i32.ge_s', 'i32.ge_u',
    'i32.clz', 'i32.ctz', 'i32.popcnt', 'i32.eqz', 'i32.wrap_i64',
    'i32.trunc_f32_s', 'i32.trunc_f32_u', 'i32.trunc_f64_s', 'i32.trunc_f64_u',
    'i32.reinterpret_f32', 'i32.trunc_sat_f32_s', 'i32.trunc_sat_f32_u',
    'i32.trunc_sat_f64_s', 'i32.trunc_sat_f64_u', 'i32.extend8_s', 'i32.extend16_s',
    // f32 instructions
    'f32.add', 'f32.sub', 'f32.mul', 'f32.div',
    'f32.abs', 'f32.neg', 'f32.sqrt', 'f32.min', 'f32.max',
    'f32.ceil', 'f32.floor', 'f32.trunc', 'f32.nearest', 'f32.copysign',
    'f32.eq', 'f32.ne', 'f32.lt', 'f32.gt', 'f32.le', 'f32.ge',
    'f32.convert_i32_s', 'f32.convert_i32_u', 'f32.convert_i64_s', 'f32.convert_i64_u',
    'f32.demote_f64', 'f32.reinterpret_i32',
    'i32.lt_s', 'i32.gt_s', 'i32.le_s', 'i32.ge_s',
    // i64 instructions
    'i64.add', 'i64.sub', 'i64.mul', 'i64.div_s', 'i64.div_u',
    'i64.rem_s', 'i64.rem_u', 'i64.and', 'i64.or', 'i64.xor',
    'i64.shl', 'i64.shr_s', 'i64.shr_u', 'i64.rotl', 'i64.rotr',
    'i64.eq', 'i64.ne', 'i64.lt_s', 'i64.lt_u', 'i64.gt_s',
    'i64.gt_u', 'i64.le_s', 'i64.le_u', 'i64.ge_s', 'i64.ge_u',
    'i64.clz', 'i64.ctz', 'i64.popcnt', 'i64.eqz', 'i64.extend8_s', 'i64.extend16_s', 'i64.extend32_s',
    'i64.trunc_f32_s', 'i64.trunc_f32_u', 'i64.trunc_f64_s', 'i64.trunc_f64_u', 'i64.reinterpret_f64',
    'i64.extend_i32_s', 'i64.extend_i32_u', 'i64.load', 'i64.trunc_sat_f32_s',
    'i64.trunc_sat_f32_u', 'i64.trunc_sat_f64_s', 'i64.trunc_sat_f64_u',
    // Add f64 operations
    'f64.add', 'f64.sub', 'f64.mul', 'f64.div',
    'f64.abs', 'f64.neg', 'f64.sqrt', 'f64.min', 'f64.max',
    'f64.ceil', 'f64.floor', 'f64.trunc', 'f64.nearest', 'f64.copysign',
    'f64.eq', 'f64.ne', 'f64.lt', 'f64.gt', 'f64.le', 'f64.ge',
    'f64.convert_i32_s', 'f64.convert_i32_u', 'f64.convert_i64_s', 'f64.convert_i64_u',
    'f64.promote_f32', 'f64.reinterpret_i64',
    'ref.is_null' // Generated by ðŸ¤–
];

export function parseInstruction(blockLabels) {
    const instrToken = peekToken(); // TODO: remove peek token here
    const position = getCurrentCursor();
    skipToken() // Skip instruction token

    const refInstruction = parseRefInstruction(instrToken, position);
    if (refInstruction) {
        return refInstruction;
    }

    const tableInstr = parseTableInstruction(instrToken, position);
    if (tableInstr) {
        return tableInstr;
    }

    const memoryOps = parseMemoryOpsInstruction(instrToken, position);
    if (memoryOps) {
        return memoryOps;
    }

    const atomicRMWInstr = parseAtomicRMWInstruction(instrToken, position);
    if (atomicRMWInstr) {
        return atomicRMWInstr;
    }

    const atomicOps = parseAtomicsOpInstruction(instrToken, position);
    if (atomicOps) {
        return atomicOps;
    }

    const simdLaneInstr = parseSIMDLaneBased(instrToken, position);
    if (simdLaneInstr) {
        return simdLaneInstr;
    }

    const simdMemoryInstr = parseSIMDMemory(instrToken, position);
    if (simdMemoryInstr) {
        return simdMemoryInstr;
    }

    const simdPlainInstr = parseSIMDPlainOpcode(instrToken, position);
    if (simdPlainInstr) {
        return simdPlainInstr;
    }

    // Continue with the original parseInstruction logic for other instructions
    const instrType = instrToken;
    if (stackInstructions.includes(instrType)) {
        // Handle stack instructions
        return { type: instrType, position };
    }
    if (instrType === 'select') {
        // Handle select instruction explicitly
        // Check if this is a typed select with a result type
        if (!atEnd() && peekToken() === '(') {
            skipToken() // Skip opening paren

            // Check for result type
            if (!atEnd() && peekToken() === 'result') {
                skipToken() // Skip 'result' keyword

                // Get the result type
                if (!atEnd()) {
                    const resultType = getToken();

                    // Skip closing paren
                    if (!atEnd() && peekToken() === ')') {
                        skipToken()
                        // Return typed select instruction
                        return { type: 'select_t', resultType, position };
                    }
                }
            }

            // If we couldn't parse a result type, skip to end of paren
            while (!atEnd() && peekToken() !== ')') {
                skipToken()
            }
            if (!atEnd() && peekToken() === ')') {
                skipToken()
            }
        }

        // Regular select instruction (no explicit type)
        return { type: 'select', position };
    }
    if (instrType === 'local.get' || instrType === 'get_local') {
        const operand = getToken();
        return { type: 'get_local', operand, position };
    }

    if (instrType === 'local.set' || instrType === 'set_local') {
        const operand = getToken();
        return { type: 'set_local', operand, position };
    }

    if (instrType === 'local.tee') {
        const operand = getToken();
        return { type: 'local.tee', operand, position };
    }

    if (instrType === 'global.get' || instrType === 'get_global') {
        const operand = getToken();
        return { type: 'global.get', operand, position };
    }

    if (instrType === 'global.set' || instrType === 'set_global') {
        const operand = getToken();
        return { type: 'global.set', operand, position };
    }

    if (instrType === 'i32.const') {
        // Modified to handle integer encoding correctly
        // First, parse the string as an integer
        const valueStr = getToken();
        // Parse the integer value, ensuring it's handled as a 32-bit signed integer
        let value;

        // Check if it's hexadecimal
        if (valueStr.toLowerCase().startsWith('0x')) {
            value = Number.parseInt(valueStr, 16);
        } else {
            value = Number.parseInt(valueStr, 10);
        }

        // Ensure the value is correctly interpreted as a 32-bit signed integer
        // This handles the wrap-around behavior of i32.const in WebAssembly
        value = value | 0;  // Force 32-bit signed integer interpretation

        return { type: 'i32.const', value, position };
    }

    if (instrType === 'i64.const') {
        // Handle 64-bit integers using BigInt
        const valueStr = getToken();
        let value = BigInt(valueStr);

        // Ensure the value is correctly interpreted as a 64-bit signed integer
        // This handles the wrap-around behavior of i64.const in WebAssembly
        value = value & BigInt("0xFFFFFFFFFFFFFFFF");

        // Convert to a signed 64-bit value if necessary (two's complement)
        if (value > BigInt("0x7FFFFFFFFFFFFFFF")) {
            value = value - BigInt("0x10000000000000000");
        }

        return { type: 'i64.const', value, position };
    }

    if (instrType === 'f32.const') {
        const value = Number.parseFloat(getToken());
        return { type: 'f32.const', value, position };
    }

    if (instrType === 'f64.const') {
        const value = Number.parseFloat(getToken());
        return { type: 'f64.const', value, position };
    }

    if (instrType === 'br') {
        const label = getToken();
        return { type: 'br', label, position };
    }

    if (instrType === 'br_if') {
        const label = getToken();
        // Store the target label and its nesting information
        const branchInstr = {
            type: 'br_if',
            label,
            labelDepth: blockLabels.has(label) ? blockLabels.get(label) : null,
            position
        };
        return branchInstr;
    }

    if (instrType === 'br_table') {
        // Generated by ðŸ¤–
        // br_table takes multiple labels followed by a default label
        const labels = [];
        let defaultLabel = null;

        // Parse all the branch table labels until we reach the end
        while (!atEnd() && (isLabel(peekToken()) || peekToken().startsWith('$'))) {
            const label = getToken();
            labels.push({ label, position });
        }

        if (labels.length > 1) {
            // Remove the last label from the list as it's the default
            defaultLabel = labels.pop();
        }

        if (labels.length === 1) {
            defaultLabel = { ...labels[0] };
        }

        // For named labels, return just the labels - the depths will be calculated during compilation
        return {
            type: 'br_table',
            labels: labels.map(l => l.label),
            defaultLabel: defaultLabel.label,
            position
        };
    }
    // Handle data.drop instruction
    if (instrType === 'data.drop') {
        // Handle named data segment reference
        if (!atEnd()) {
            if (peekToken().startsWith('$')) {
                const dataLabel = getToken();
                return { type: 'data.drop', dataLabel, position };
            }
        }
        return { type: 'data.drop', position };
    }
    // Generated by ðŸ¤–
    // Handle memory.init instruction with explicit segment index
    if (instrType === 'memory.init') {
        // Check if next token is a number (segment index)
        let segmentIdx = 1; // Default to 1 if not specified
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            segmentIdx = Number.parseInt(peekToken(), 10);
            skipToken() // Skip segment index
        }
        return { type: 'memory.init', segmentIdx, position };
    }
    // Handle data.drop instruction with explicit segment index
    if (instrType === 'data.drop') {
        // Check if next token is a number (segment index)
        let segmentIdx = 1; // Default to 1 if not specified
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            segmentIdx = Number.parseInt(peekToken(), 10);
            skipToken() // Skip segment index
        }
        return { type: 'data.drop', segmentIdx, position };
    }
    // Handle elem.drop instruction
    if (instrType === 'elem.drop') {
        // Check if next token is a number (element index)
        let elementIdx = 0; // Default to 0 if not specified
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            elementIdx = Number.parseInt(peekToken(), 10);
            skipToken() // Skip element index
        }
        return { type: 'elem.drop', elementIdx, position };
    }

    if (instrType === 'call') {
        const funcIndex = getToken();
        return { type: 'call', functionName: funcIndex, position };
    }

    if (instrType === 'call_indirect') {
        // Generated by ðŸ¤–
        const params = [];
        const results = [];
        let typeRef = null;
        let tableIndex = 0; // Default to first table

        // Handle inline type information in call_indirect
        // Process (param i32 i32) (result i32) format
        while (!atEnd() && peekToken() === '(') {
            skipToken(); // Skip opening paren

            if (!atEnd()) {
                const keyword = getToken();

                if (keyword === 'type') {
                    // Handle (type $typename) reference
                    if (!atEnd()) {
                        typeRef = getToken();
                    }
                } else if (keyword === 'param') {
                    // Parse parameter types
                    while (!atEnd() && peekToken() !== ')') {
                        params.push(getToken());
                    }
                } else if (keyword === 'result') {
                    // Parse result types
                    while (!atEnd() && peekToken() !== ')') {
                        results.push(getToken());
                    }
                }

                // Skip closing paren
                if (!atEnd() && peekToken() === ')') {
                    skipToken();
                }
            }
        }

        // Check for table index (optional, defaults to 0)
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            tableIndex = Number.parseInt(getToken(), 10);
        }

        return {
            type: 'call_indirect',
            params,
            results,
            typeRef,
            tableIndex,
            position
        };
    }
    // For unrecognized instructions, return a generic instruction
    const error = new Error(`Unrecognized instruction: ${instrType} at line: ${position.line} and column: ${position.column}`);
    error.context = {};
    error.context.position = {
        line: position.line,
        column: position.column
    };
    error.context.instruction = instrType;

    throw error;
}