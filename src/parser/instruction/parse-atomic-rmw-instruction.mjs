import { atEnd } from '../tape.mjs';

export function parseAtomicRMWInstruction(instrToken, position) {
    if (atEnd()) return null;

    // Generated by ðŸ¤–
    // Handle atomic RMW operations with inline offset/align attributes
    if (typeof instrToken === 'string' && instrToken.startsWith('i32.atomic.rmw')) {
        // Set proper alignment based on bit width
        let align = 2; // Default for i32 (4 bytes = 2^2)
        
        // Check if it's an 8-bit or 16-bit operation
        if (instrToken.includes('rmw8')) {
            align = 0; // 8-bit operations (1 byte = 2^0)
        } else if (instrToken.includes('rmw16')) {
            align = 1; // 16-bit operations (2 bytes = 2^1)
        }

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch && offsetMatch[1]) {
            offset = parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch && alignMatch[1]) {
            align = parseInt(alignMatch[1], 10);
        }

        // Get the base operation type
        let op = instrToken;

        // Create instruction object with type field for AST compatibility
        // Generated by ðŸ¤–
        return { type: op, op, memarg: { align, offset }, position };
    }

    // Handle i64.atomic.rmw operations
    if (typeof instrToken === 'string' && instrToken.startsWith('i64.atomic.rmw')) {
        // Set proper alignment based on bit width
        let align = 3; // Default for i64 (8 bytes = 2^3)
        
        // Check for different bit widths
        if (instrToken.includes('rmw8')) {
            align = 0; // 8-bit operations (1 byte = 2^0)
        } else if (instrToken.includes('rmw16')) {
            align = 1; // 16-bit operations (2 bytes = 2^1)
        } else if (instrToken.includes('rmw32')) {
            align = 2; // 32-bit operations (4 bytes = 2^2)
        }

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch && offsetMatch[1]) {
            offset = parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch && alignMatch[1]) {
            align = parseInt(alignMatch[1], 10);
        }

        // Get the base operation type
        let op = instrToken;

        // Create instruction object with type field for AST compatibility
        // Generated by ðŸ¤–
        return { type: op, op, memarg: { align, offset }, position };
    }

    return null;
}