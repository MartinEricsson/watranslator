import { atEnd, peekToken, skipToken, getToken } from '../tape.mjs';
import { createError } from '../parse-util.mjs';

function parseOffsetAndAlign() {
    let align = 0; // Default alignment
    let offset = 0; // Default offset

    // Process attributes in any order
    while (!atEnd()) {
        const nextToken = peekToken();
        
        if (nextToken.startsWith('align=')) {
            align = parseInt(nextToken.split('=')[1], 10);
            skipToken();
        } else if (nextToken.startsWith('offset=')) {
            offset = parseInt(nextToken.split('=')[1], 10);
            skipToken();
        } else {
            // Not a memory attribute, stop processing
            break;
        }
    }

    return { align, offset }; // Generated by ðŸ¤–
}

export function parseSIMDMemory(instrToken, position) {
    if (typeof instrToken !== 'string') {
        return false;
    }

    // Basic vector memory operations
    if (instrToken === 'v128.load' || instrToken === 'v128.store' ||
        instrToken === 'v128.load8x8_s' || instrToken === 'v128.load8x8_u' || 
        instrToken === 'v128.load16x4_s' || instrToken === 'v128.load16x4_u' ||
        instrToken === 'v128.load32x2_s' || instrToken === 'v128.load32x2_u' ||
        instrToken === 'v128.load8_splat' || instrToken === 'v128.load16_splat' || 
        instrToken === 'v128.load32_splat' || instrToken === 'v128.load64_splat' ||
        instrToken === 'v128.load32_zero' || instrToken === 'v128.load64_zero') {
        // Parse alignment and offset if present
        const {align, offset} = parseOffsetAndAlign();

        // Create and return the instruction object
        return { type: instrToken, align, offset, position };
    }
    
    // Lane-based loads and stores
    if (instrToken === 'v128.load8_lane' || instrToken === 'v128.load16_lane' || 
        instrToken === 'v128.load32_lane' || instrToken === 'v128.load64_lane' ||
        instrToken === 'v128.store8_lane' || instrToken === 'v128.store16_lane' || 
        instrToken === 'v128.store32_lane' || instrToken === 'v128.store64_lane') {
        
        let laneIndex = 0;
        
        const {align, offset} = parseOffsetAndAlign(); // Generated by ðŸ¤–
        
        // Parse lane index
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            laneIndex = parseInt(getToken(), 10);
            
            // Validate lane index based on operation size
            if ((instrToken.includes('8_lane') && (laneIndex < 0 || laneIndex > 15)) ||
                (instrToken.includes('16_lane') && (laneIndex < 0 || laneIndex > 7)) ||
                (instrToken.includes('32_lane') && (laneIndex < 0 || laneIndex > 3)) ||
                (instrToken.includes('64_lane') && (laneIndex < 0 || laneIndex > 1))) {
                throw createError(`${instrToken} has invalid lane index: ${laneIndex}`);
            }
        }
        
        return { type: instrToken, align, offset, laneIndex, position };
    }

    return false;
}
// Generated by ðŸ¤–