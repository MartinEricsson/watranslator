import { atEnd, peekToken, skipToken, getToken } from '../tape.mjs';
import { createError, parseDecimalOrHex, parseSigned64BitHex } from '../parse-util.mjs';

export function parseSIMDLaneBased(instrToken, position) {
    if (typeof instrToken !== 'string') {
        return false;
    }

    // Handle v128.const instruction
    if (instrToken === 'v128.const') {
        // Check for the shape format (i8x16, i16x8, etc.)
        if (!atEnd()) {
            const shape = getToken();
            const immediates = [];

            // Determine max values based on shape
            let maxValues = 16; // Default for i8x16

            if (shape === 'i16x8' || shape === 'i16x8_splat') {
                maxValues = 8;
            } else if (shape === 'i32x4' || shape === 'i32x4_splat' || shape === 'f32x4' || shape === 'f32x4_splat') {
                maxValues = 4;
            } else if (shape === 'i64x2' || shape === 'i64x2_splat' || shape === 'f64x2' || shape === 'f64x2_splat') {
                maxValues = 2;
            }

            // Parse immediate values based on shape
            while (!atEnd() && peekToken() !== ')' && immediates.length < maxValues) {
                if (/^-?(0x[0-9a-fA-F]+|\d+(\.\d+)?)$/.test(peekToken())) {
                    // Parse number value (integer or float, including hex)
                    const token = getToken();
                    // Use parseFloat for f32/f64 shapes, parseInt otherwise
                    const isFloat = shape.startsWith('f') || token.includes('.');
                    const is64Bit = shape.startsWith('i64') || shape.startsWith('f64');
                    const value = isFloat ? parseFloat(token) : is64Bit ? parseSigned64BitHex(token) : parseDecimalOrHex(token);
                    immediates.push(value);
                } else {
                    // Skip non-numeric tokens
                    skipToken(); //TODO: Check this
                } // Generated by 🤖
            } // Generated by 🤖

            // Validate number of immediate values based on the shape
            let expectedValues = 16; // Default for i8x16

            if (shape === 'i16x8' || shape === 'i16x8_splat') {
                expectedValues = 8;
            } else if (shape === 'i32x4' || shape === 'i32x4_splat' || shape === 'f32x4' || shape === 'f32x4_splat') {
                expectedValues = 4;
            } else if (shape === 'i64x2' || shape === 'i64x2_splat' || shape === 'f64x2' || shape === 'f64x2_splat') {
                expectedValues = 2;
            }

            if (immediates.length !== expectedValues) {
                throw createError(`v128.const with shape ${shape} requires exactly ${expectedValues} values, got ${immediates.length}`);
            } // Generated by 🤖

            return { type: 'v128.const', opcode: 'v128.const', shape, immediates, position };
        }

        return { type: 'v128.const', opcode: 'v128.const', immediates: [], position };
    }

    // Handle i8x16.shuffle instruction
    if (instrToken === 'i8x16.shuffle') {
        const laneIndices = [];

        // Parse 16 lane indices (must be 0-31)
        while (!atEnd() && peekToken() !== ')' && laneIndices.length < 16) {
            if (/^[0-9]+$/.test(peekToken())) {
                // Parse lane index
                const index = parseInt(getToken(), 10);

                // Validate lane index (must be 0-31 for i8x16.shuffle)
                if (index < 0 || index > 31) {
                    throw createError(`i8x16.shuffle lane index must be 0-31, got ${index}`);
                }

                laneIndices.push(index);
            } else {
                // Skip non-numeric tokens
                skipToken();
            }
        }

        // Ensure we have exactly 16 lane indices
        if (laneIndices.length !== 16) {
            throw createError(`i8x16.shuffle requires exactly 16 lane indices, got ${laneIndices.length}`);
        }

        return { type: 'i8x16.shuffle', opcode: 'i8x16.shuffle', laneIndices, position };
    } // Generated by 🤖

    // Handle all extract_lane instructions for different SIMD formats
    if (instrToken === 'i8x16.extract_lane_u' || instrToken === 'i8x16.extract_lane_s' ||
        instrToken === 'i16x8.extract_lane_s' || instrToken === 'i16x8.extract_lane_u' ||
        instrToken === 'i32x4.extract_lane' || instrToken === 'i64x2.extract_lane' ||
        instrToken === 'f32x4.extract_lane' || instrToken === 'f64x2.extract_lane') {
        let laneIndex = 0;

        // Parse lane index
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            laneIndex = parseInt(getToken(), 10);

            // Validate lane index based on SIMD format
            if (instrToken.startsWith('i8x16') && (laneIndex < 0 || laneIndex > 15)) {
                throw createError(`${instrToken} lane index must be 0-15, got ${laneIndex}`);
            } else if (instrToken.startsWith('i16x8') && (laneIndex < 0 || laneIndex > 7)) {
                throw createError(`${instrToken} lane index must be 0-7, got ${laneIndex}`);
            } else if ((instrToken.startsWith('i32x4') || instrToken.startsWith('f32x4')) && (laneIndex < 0 || laneIndex > 3)) {
                throw createError(`${instrToken} lane index must be 0-3, got ${laneIndex}`);
            } else if ((instrToken.startsWith('i64x2') || instrToken.startsWith('f64x2')) && (laneIndex < 0 || laneIndex > 1)) {
                throw createError(`${instrToken} lane index must be 0-1, got ${laneIndex}`);
            }
        } // Generated by 🤖

        return { type: instrToken, opcode: instrToken, laneIndex, position };
    } // Generated by 🤖

    // Handle all replace_lane instructions for different SIMD formats
    if (instrToken === 'i8x16.replace_lane' ||
        instrToken === 'i16x8.replace_lane' ||
        instrToken === 'i32x4.replace_lane' ||
        instrToken === 'i64x2.replace_lane' ||
        instrToken === 'f32x4.replace_lane' ||
        instrToken === 'f64x2.replace_lane') {
        let laneIndex = 0;

        // Parse lane index
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            laneIndex = parseInt(getToken(), 10);

            // Validate lane index based on SIMD format
            if (instrToken.startsWith('i16x8') && (laneIndex < 0 || laneIndex > 7)) {
                throw createError(`${instrToken} lane index must be 0-7, got ${laneIndex}`);
            } else if ((instrToken.startsWith('i32x4') || instrToken.startsWith('f32x4')) && 
                      (laneIndex < 0 || laneIndex > 3)) {
                throw createError(`${instrToken} lane index must be 0-3, got ${laneIndex}`);
            } else if ((instrToken.startsWith('i64x2') || instrToken.startsWith('f64x2')) && 
                      (laneIndex < 0 || laneIndex > 1)) {
                throw createError(`${instrToken} lane index must be 0-1, got ${laneIndex}`);
            }
        }

        return { type: instrToken, opcode: instrToken, laneIndex, position };
    } // Generated by 🤖

    return false;
} // Generated by 🤖