import { atEnd } from '../tape.mjs';

export function parseAtomicsOpInstruction(instrToken, position) {
    if (atEnd()) return null;

    // Handle atomic load/store instructions
    if (typeof instrToken === 'string' && (instrToken.startsWith('i32.atomic.') || instrToken.startsWith('i64.atomic.'))) {
        const is64Bit = instrToken.startsWith('i64.');
        // Generated by ðŸ¤–
        const is8Bit = instrToken.includes('8_') || instrToken.includes('store8');
        const is16Bit = instrToken.includes('16_') || instrToken.includes('store16');
        const is32Bit = instrToken.includes('32_') || instrToken.includes('store32');

        // Set default align value based on operation size
        let align;
        if (is8Bit) {
            align = 0; // 8-bit operations (1 byte = 2^0)
        } else if (is16Bit) {
            align = 1; // 16-bit operations (2 bytes = 2^1)
        } else if (is32Bit) {
            align = 2; // 32-bit operations (4 bytes = 2^2)
        } else {
            // Full-sized operations
            align = is64Bit ? 3 : 2; // 3 for i64 (8 bytes = 2^3), 2 for i32 (4 bytes = 2^2)
        }

        // Extract offset if present
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch && offsetMatch[1]) {
            offset = parseInt(offsetMatch[1], 10);
        }

        // Extract align if present
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch && alignMatch[1]) {
            align = parseInt(alignMatch[1], 10);
        }

        // Get the instruction type without attributes (the part before any space)
        const op = instrToken.split(/\s+/)[0];

        return { type: op, op, offset, align, position };
    }

    return null;
}