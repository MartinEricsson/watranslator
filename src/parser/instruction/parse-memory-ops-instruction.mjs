import { atEnd, getToken, peekToken } from '../tape.mjs';

export function parseMemoryOpsInstruction(instrToken, position) {
    if (atEnd()) return null;

    // Handle memory instructions with inline offset/align attributes
    if (typeof instrToken === 'string' && instrToken.startsWith('i32.load')) {
        // Special handling for memory instructions with offset in the token (e.g. "i32.load offset=4")
        const isLoad8S = instrToken.includes('load8_s');
        const isLoad8U = instrToken.includes('load8_u');
        const isLoad16S = instrToken.includes('load16_s');
        const isLoad16U = instrToken.includes('load16_u');

        // Set default align value based on load type
        let align = 2; // Default for i32.load
        if (isLoad8S || isLoad8U) align = 0;
        if (isLoad16S || isLoad16U) align = 1;

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Determine instruction type
        let type = 'i32.load';
        if (isLoad8S) type = 'i32.load8_s';
        else if (isLoad8U) type = 'i32.load8_u';
        else if (isLoad16S) type = 'i32.load16_s';
        else if (isLoad16U) type = 'i32.load16_u';

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        // Create instruction object
        return { type, offset, align, memoryRef, position };
    }

    // Generated by 
    // Handle i64.load8_s and i64.load8_u with default align=0
    if (typeof instrToken === 'string' && (instrToken.startsWith('i64.load8_s') || instrToken.startsWith('i64.load8_u'))) {
        // Default align for byte loads should be 0
        let align = 0;
        let offset = 0;

        // Extract offset if present
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Determine instruction type
        const type = instrToken.includes('load8_s') ? 'i64.load8_s' : 'i64.load8_u';

        return { type, offset, align, position };
    }

    if (typeof instrToken === 'string' && (instrToken.startsWith('i64.load16_s') || instrToken.startsWith('i64.load16_u'))) {
        // Default align for byte loads should be 0
        let align = 0;
        let offset = 0;

        // Extract offset if present
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Determine instruction type
        const type = instrToken.includes('load16_s') ? 'i64.load16_s' : 'i64.load16_u';

        return { type, offset, align, position };
    }

    if (typeof instrToken === 'string' && (instrToken.startsWith('i64.load32_s') || instrToken.startsWith('i64.load32_u'))) {
        // Default align for byte loads should be 0
        let align = 0;
        let offset = 0;

        // Extract offset if present
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Determine instruction type
        const type = instrToken.includes('load32_s') ? 'i64.load32_s' : 'i64.load32_u';

        return { type, offset, align, position };
    }

    // Handle i64.load* instructions with memory references
    if (typeof instrToken === 'string' && instrToken.startsWith('i64.load')) {
        // Set default align value for i64.load
        let align = 3; // Default for i64 (8 bytes alignment)
        let isLoad8S = instrToken.includes('load8_s');
        let isLoad8U = instrToken.includes('load8_u');
        let isLoad16S = instrToken.includes('load16_s');
        let isLoad16U = instrToken.includes('load16_u');
        let isLoad32S = instrToken.includes('load32_s');
        let isLoad32U = instrToken.includes('load32_u');

        // Adjust align based on load type
        if (isLoad8S || isLoad8U) align = 0;
        if (isLoad16S || isLoad16U) align = 1;
        if (isLoad32S || isLoad32U) align = 2;

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Determine instruction type
        let type = 'i64.load';
        if (isLoad8S) type = 'i64.load8_s';
        else if (isLoad8U) type = 'i64.load8_u';
        else if (isLoad16S) type = 'i64.load16_s';
        else if (isLoad16U) type = 'i64.load16_u';
        else if (isLoad32S) type = 'i64.load32_s';
        else if (isLoad32U) type = 'i64.load32_u';

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        // Create instruction object
        return { type, offset, align, memoryRef, position };
    } // Generated by 

    // Handle store instructions with inline offset/align attributes
    if (typeof instrToken === 'string' && instrToken.startsWith('i32.store')) {
        // Special handling for store instructions with offset in the token
        const isStore8 = instrToken.includes('store8');
        const isStore16 = instrToken.includes('store16');

        // Set default align value based on store type
        let align = 2; // Default for i32.store
        if (isStore8) align = 0;
        if (isStore16) align = 1;

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Determine instruction type
        let type = 'i32.store';
        if (isStore8) type = 'i32.store8';
        else if (isStore16) type = 'i32.store16';

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        // Create instruction object
        return { type, offset, align, memoryRef, position };
    } // Generated by 

    // Generated by 
    // Handle i64.store instructions with inline offset/align attributes
    if (typeof instrToken === 'string' && instrToken.startsWith('i64.store')) {
        const isStore8 = instrToken.includes('store8');
        const isStore16 = instrToken.includes('store16');
        const isStore32 = instrToken.includes('store32');

        // Set default align value based on store type
        let align = 3; // Default for i64.store (8 bytes = 2^3)
        if (isStore8) align = 0;
        if (isStore16) align = 1;
        if (isStore32) align = 2;

        // Extract offset if present
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Determine instruction type
        let type = 'i64.store';
        if (isStore8) type = 'i64.store8';
        else if (isStore16) type = 'i64.store16';
        else if (isStore32) type = 'i64.store32';

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        return { type, offset, align, memoryRef, position };
    }

    // Handle f32.load instructions with inline offset/align attributes
    // Generated by 
    if (typeof instrToken === 'string' && instrToken.startsWith('f32.load')) {
        // Set default align value for f32.load
        let align = 2; // Default for f32.load (4 bytes alignment)

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        // Create instruction object
        return { type: 'f32.load', offset, align, memoryRef, position };
    }

    // Handle f64.load instructions with inline offset/align attributes
    // Generated by 
    if (typeof instrToken === 'string' && instrToken.startsWith('f64.load')) {
        // Set default align value for f64.load
        let align = 3; // Default for f64.load (8 bytes alignment = 2^3)

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        // Create instruction object
        return { type: 'f64.load', offset, align, memoryRef, position };
    }

    // Handle f32.store instructions with inline offset/align attributes
    // Generated by 
    if (typeof instrToken === 'string' && instrToken.startsWith('f32.store')) {
        // Set default align value for f32.store
        let align = 2; // Default for f32.store (4 bytes alignment)

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        // Create instruction object
        return { type: 'f32.store', offset, align, memoryRef, position };
    } // Generated by 

    // Handle f64.store instructions with inline offset/align attributes
    // Generated by 
    if (typeof instrToken === 'string' && instrToken.startsWith('f64.store')) {
        // Set default align value for f64.store
        let align = 3; // Default for f64.store (8 bytes alignment)

        // Extract offset if present in the token
        let offset = 0;
        const offsetMatch = instrToken.match(/offset=(\d+)/);
        if (offsetMatch?.[1]) {
            offset = Number.parseInt(offsetMatch[1], 10);
        }

        // Extract align if present in the token
        const alignMatch = instrToken.match(/align=(-?\d+)/);
        if (alignMatch?.[1]) {
            align = Number.parseInt(alignMatch[1], 10);
        }

        // Check for memory reference - either a name ($mem1) or an index (0, 1, etc.)
        let memoryRef = null;
        if (!atEnd()) {
            // Handle named memory reference
            if (peekToken().startsWith('$')) {
                memoryRef = getToken();
            }
            // Handle numeric memory index
            else if (/^\d+$/.test(peekToken())) {
                memoryRef = Number.parseInt(getToken(), 10);
            }
        }

        // Create instruction object
        return { type: 'f64.store', offset, align, memoryRef, position };
    }

    return null;
}