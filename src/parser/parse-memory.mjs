import { atEnd, peekToken, getToken, getCurrentCursor, skipToken } from './tape.mjs';

// Generated by 🤖
export function parseMemory() {
    // Parse memory declaration: (memory <size>)
    // or (memory <min> <max>)
    // or (memory <min> <max> shared)
    // or (memory (export "memory") <min>)
    // or (memory $id <min>)
    // or (memory $id <min> <max>)
    // or (memory $id <min> <max> shared)
    let min = 0;
    let max = null;
    let id = null;
    let shared = false;
    let exportName = null;
    let index = null; // Memory index for multiple memories
    let minWasParsed = false; // Generated by 🤖: Flag to track if min was explicitly parsed

    // Check for memory identifier
    if (!atEnd() && peekToken().startsWith('$')) {
        id = getToken();
    }

    // Handle export declaration like (export "memory")
    if (!atEnd() && peekToken() === '(') {
        skipToken(); // Skip opening paren

        if (!atEnd() && peekToken() === 'export') {
            getToken(); // consume 'export' token

            // Parse export name (string)
            if (!atEnd() && peekToken().startsWith('"') && peekToken().endsWith('"')) {
                const token = getToken();
                exportName = token.substring(1, token.length - 1); // Remove quotes
            }

            // Skip closing paren
            if (!atEnd() && peekToken() === ')') {
                skipToken();
            }
        } else {
            // If not export, revert and continue with normal parsing
            skipToken(); // Skip whatever token came after the '('
            if (!atEnd() && peekToken() === ')') {
                skipToken(); // Skip closing paren
            }
        }
    }

    // Parse memory index if present (number literal)
    if (!atEnd() && /^\d+$/.test(peekToken())) {
        // Generated by 🤖: Temporarily store as index, may be reassigned to min later
        index = Number.parseInt(getToken(), 10);
    }

    // Parse minimum size (required)
    if (!atEnd() && /^\d+$/.test(peekToken())) {
        min = Number.parseInt(getToken(), 10);
        minWasParsed = true; // Generated by 🤖: Mark min as parsed

        // Parse maximum size (optional)
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            max = Number.parseInt(getToken(), 10);

            // Check for shared attribute
            if (!atEnd() && peekToken() === 'shared') {
                getToken(); // consume 'shared' token
                shared = true;
            }
        }
    }

    // Generated by 🤖
    // If 'index' was parsed (i.e., a number was found directly after 'memory' or 'memory $id')
    // but 'min' was NOT explicitly parsed by a subsequent number, and 'max' is also null,
    // then the number initially parsed as 'index' is actually 'min'.
    // In this scenario, 'index' should be defaulted to 0.
    if (index !== null && !minWasParsed && max === null) {
        min = index; // The first number was 'min'
        index = 0;   // Default 'index' to 0
    }

    // Default index to 0 if it wasn't specified or correctly set above.
    if (index === null) {
        index = 0;
    }
    // End Generated by 🤖

    // Check for shared attribute at any position (more flexible parsing)
    if (!shared && !atEnd() && peekToken() === 'shared') {
        getToken(); // consume 'shared' token
        shared = true;
    }

    const position = getCurrentCursor();

    // Ensure min has a valid value
    if (min < 0) {
        throw new Error("Memory size cannot be negative");
    }

    return { id, min, max, shared, exportName, index, position }; // Generated by 🤖
}