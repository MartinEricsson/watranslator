import { atEnd, peekToken, getToken, getCurrentCursor, skipToken } from './tape.mjs';

// Generated by ðŸ¤–
export function parseMemory() {
    // Parse memory declaration: (memory <size>)
    // or (memory <min> <max>)
    // or (memory <min> <max> shared)
    // or (memory (export "memory") <min>)
    // or (memory $id <min>)
    // or (memory $id <min> <max>)
    // or (memory $id <min> <max> shared)
    let min = 0;
    let max = null;
    let id = null;
    let shared = false;
    let exportName = null;
    let index = null; // Memory index for multiple memories

    // Check for memory identifier
    if (!atEnd() && peekToken().startsWith('$')) {
        id = getToken();
    }

    // Handle export declaration like (export "memory")
    if (!atEnd() && peekToken() === '(') {
        skipToken(); // Skip opening paren

        if (!atEnd() && peekToken() === 'export') {
            getToken(); // consume 'export' token

            // Parse export name (string)
            if (!atEnd() && peekToken().startsWith('"') && peekToken().endsWith('"')) {
                const token = getToken();
                exportName = token.substring(1, token.length - 1); // Remove quotes
            }

            // Skip closing paren
            if (!atEnd() && peekToken() === ')') {
                skipToken();
            }
        } else {
            // If not export, revert and continue with normal parsing
            skipToken(); // Skip whatever token came after the '('
            if (!atEnd() && peekToken() === ')') {
                skipToken(); // Skip closing paren
            }
        }
    }

    // Parse memory index if present (number literal)
    if (!atEnd() && /^\d+$/.test(peekToken())) {
        index = Number.parseInt(getToken(), 10);
    }

    // Parse minimum size (required)
    if (!atEnd() && /^\d+$/.test(peekToken())) {
        min = Number.parseInt(getToken(), 10);

        // Parse maximum size (optional)
        if (!atEnd() && /^\d+$/.test(peekToken())) {
            max = Number.parseInt(getToken(), 10);

            // Check for shared attribute
            if (!atEnd() && peekToken() === 'shared') {
                getToken(); // consume 'shared' token
                shared = true;
            }
        }
    }

    // Check for shared attribute at any position (more flexible parsing)
    if (!shared && !atEnd() && peekToken() === 'shared') {
        getToken(); // consume 'shared' token
        shared = true;
    }

    const position = getCurrentCursor();

    // Ensure min has a valid value
    if (min < 0) {
        throw new Error("Memory size cannot be negative");
    }
    if (min === 0) {
        min = 1; // Default to at least 1 page for atomic operations
    }

    return { id, min, max, shared, exportName, index, position }; // Generated by ðŸ¤–
}