import { peekToken, atEnd, skipToken, getToken } from './tape.mjs';
import { parseInstruction } from './parse-instruction.mjs';

function isParamType(candidate) {
    return candidate === 'i32' ||
        candidate === 'i64' ||
        candidate === 'f32' ||
        candidate === 'f64' ||
        candidate === 'v128' ||
        candidate === 'anyfunc' ||
        candidate === 'funcref' ||
        candidate === 'externref';
}

export function parseFunction() {
    let name = null;
    const params = [];
    const results = [];
    const locals = [];
    const instructions = [];
    const blockStack = []; // Stack to track nested blocks
    let exportName = null; // New variable to capture inline export
    let typeRef = null; // Store type reference if the function uses one
    let importInfo = null; // Generated by  - Store import info if function is imported

    // Track block labels and their depths for br_if resolution
    const blockLabels = new Map();

    // Check for function name
    if (!atEnd() && peekToken().startsWith('$')) {
        name = getToken();
    }

    // Parse parameters, results, locals and body
    while (!atEnd() && peekToken() !== ')') {
        if (peekToken() === '(') {
            skipToken() // Skip opening paren

            if (!atEnd()) {
                const keyword = peekToken();
                skipToken() // Skip keyword

                if (keyword === 'type') {
                    // Generated by 
                    // Handle type reference: (func (type $typeName) ...)
                    // Get the type reference
                    if (!atEnd()) {
                        typeRef = peekToken();
                        skipToken() // Skip type reference
                    }

                    // Skip closing paren of type reference
                    if (!atEnd() && peekToken() === ')') {
                        skipToken()
                    }
                } else if (keyword === 'param') {
                    // Parse parameter: (param $name type) or (param type)

                    if (!atEnd() && peekToken().startsWith('$')) {
                        // Named parameter: (param $name type)
                        const name = getToken();

                        if (!atEnd()) {
                            const type = getToken();
                            params.push({ name, type });
                        }
                    } else if (!atEnd()) {
                        // Unnamed parameter: (param type)
                        let type = peekToken();
                        while (isParamType(type)) {
                            skipToken()
                            // Use index as name for unnamed parameters
                            const name = params.length.toString();
                            params.push({ name, type });
                            type = peekToken();
                        }
                    }
                } else if (keyword === 'result') {
                    // Parse result: (result type1 type2 ...)
                    // Read all types until closing paren
                    while (!atEnd() && peekToken() !== ')') {
                        results.push(peekToken());
                        skipToken()
                    }
                } else if (keyword === 'local') {
                    // Parse local: (local $name type) or anonymous (local type)
                    let localName = null;
                    let localType = null;

                    if (!atEnd() && peekToken().startsWith('$')) {
                        localName = getToken();
                    }

                    if (!atEnd()) {
                        localType = getToken();
                    }

                    if (localType) {
                        // Support anonymous locals (no name)
                        if (!localName) {
                            // Use index as name for anonymous locals
                            localName = locals.length.toString();
                        }
                        locals.push({ name: localName, type: localType });
                    } // Generated by 
                } else if (keyword === 'export') {
                    // Handle inline export: (export "name")
                    if (!atEnd() && peekToken().startsWith('"') && peekToken().endsWith('"')) {
                        const token = getToken();
                        exportName = token.substring(1, token.length - 1); // Remove quotes
                    }
                } else if (keyword === 'import') {
                    // Generated by 
                    // Handle function import: (import "module" "name")
                    let importModule = null;
                    let importName = null;

                    // Parse module name (first string)
                    if (!atEnd() && peekToken().startsWith('"') && peekToken().endsWith('"')) {
                        const moduleStr = getToken();
                        importModule = moduleStr.substring(1, moduleStr.length - 1); // Remove quotes
                    }

                    // Parse field name (second string)
                    if (!atEnd() && peekToken().startsWith('"') && peekToken().endsWith('"')) {
                        const fieldStr = getToken();
                        importName = fieldStr.substring(1, fieldStr.length - 1); // Remove quotes
                    }

                    // Store import info in the function
                    if (importModule && importName) {
                        importInfo = { module: importModule, field: importName };
                    }
                } else {
                    // Skip other expressions
                    while (!atEnd() && peekToken() !== ')') {
                        skipToken()
                    }
                }
            }

            // Skip the closing paren
            if (!atEnd() && peekToken() === ')') {
                skipToken()
            }
        } else if (peekToken() === 'block') {
            skipToken() // Skip 'block' keyword

            let label = null;
            let resultType = null;

            // Parse block label if present
            if (!atEnd() && peekToken().startsWith('$')) {
                label = getToken();

                // Store the label with its nesting depth for branch resolution
                blockLabels.set(label, blockStack.length);
            }

            // Generated by 
            // Parse result type if present
            if (!atEnd() && peekToken() === '(') {
                skipToken() // Skip opening paren
                if (!atEnd() && peekToken() === 'result') {
                    skipToken() // Skip 'result' keyword

                    // Collect all result types
                    const resultTypes = [];
                    while (!atEnd() && peekToken() !== ')') {
                        resultTypes.push(getToken());
                    }

                    // If there's only one result type, store it as a string
                    // Otherwise, store as an array of types for multi-value returns
                    if (resultTypes.length === 1) {
                        resultType = resultTypes[0];
                    } else if (resultTypes.length > 1) {
                        resultType = resultTypes;
                    }

                    // Skip closing paren of result type
                    if (!atEnd() && peekToken() === ')') {
                        skipToken()
                    }
                }
            }

            const blockInstr = {
                type: 'block',
                label: label,
                resultType: resultType,
                instructions: []
            };

            // Add this block to its parent's instructions or the main function body
            if (blockStack.length > 0) {
                const parentBlock = blockStack[blockStack.length - 1];
                parentBlock.instructions.push(blockInstr);
            } else {
                // Add to main function body
                instructions.push(blockInstr);
            }

            // Push this block to the stack to collect its instructions
            blockStack.push(blockInstr);
        } else if (peekToken() === 'loop') {
            skipToken() // Skip 'loop' keyword

            let label = null;
            let resultType = null;

            // Parse loop label if present
            if (!atEnd() && peekToken().startsWith('$')) {
                label = getToken();

                // Store the label with its nesting depth for branch resolution
                blockLabels.set(label, blockStack.length);
            }

            // Parse result type if present
            if (!atEnd() && peekToken() === '(') {
                skipToken() // Skip opening paren
                if (!atEnd() && peekToken() === 'result') {
                    skipToken() // Skip 'result' keyword

                    // Generated by 
                    // Collect all result types
                    const resultTypes = [];
                    while (!atEnd() && peekToken() !== ')') {
                        resultTypes.push(getToken());
                    }

                    // If there's only one result type, store it as a string
                    // Otherwise, store as an array of types for multi-value returns
                    if (resultTypes.length === 1) {
                        resultType = resultTypes[0];
                    } else if (resultTypes.length > 1) {
                        resultType = resultTypes;
                    }

                    // Skip closing paren of result type
                    if (!atEnd() && peekToken() === ')') {
                        skipToken()
                    }
                }
            }

            const loopInstr = {
                type: 'loop',
                label: label,
                resultType: resultType,
                instructions: []
            };

            // Add this loop to its parent's instructions or the main function body
            if (blockStack.length > 0) {
                const parentBlock = blockStack[blockStack.length - 1];
                parentBlock.instructions.push(loopInstr);
            } else {
                // Add to main function body
                instructions.push(loopInstr);
            }

            // Push this loop to the stack to collect its instructions
            blockStack.push(loopInstr);
        } else if (peekToken() === 'if') {
            skipToken() // Skip 'if' keyword

            let resultType = null;

            // Generated by 
            // Check for result type, handling multi-value results
            if (!atEnd() && peekToken() === '(') {
                skipToken() // Skip opening paren
                if (!atEnd() && peekToken() === 'result') {
                    skipToken() // Skip 'result' keyword

                    // Collect all result types
                    const resultTypes = [];
                    while (!atEnd() && peekToken() !== ')') {
                        resultTypes.push(getToken());
                    }

                    // If there's only one result type, store it as a string
                    // Otherwise, store as an array of types for multi-value returns
                    if (resultTypes.length === 1) {
                        resultType = resultTypes[0];
                    } else if (resultTypes.length > 1) {
                        resultType = resultTypes;
                    }

                    // Skip closing paren of result type
                    if (!atEnd() && peekToken() === ')') {
                        skipToken()
                    }
                }
            }

            const ifInstr = {
                type: 'if',
                resultType: resultType,
                thenInstructions: [],
                elseInstructions: [],
                inElseBranch: false
            };

            // Add this if to its parent's instructions or the main function body
            if (blockStack.length > 0) {
                const parentBlock = blockStack[blockStack.length - 1];
                parentBlock.instructions.push(ifInstr);
            } else {
                // Add to main function body
                instructions.push(ifInstr);
            }

            // Push this if block to the stack to collect its instructions
            blockStack.push(ifInstr);
        } else if (peekToken() === 'else') {
            // Handle else branch - switch current if block to collect else instructions
            if (blockStack.length > 0) {
                const currentBlock = blockStack[blockStack.length - 1];
                if (currentBlock.type === 'if') {
                    currentBlock.inElseBranch = true;
                }
            }
            skipToken()
        } else if (peekToken() === 'end') {
            // Handle end of a block - pop the current block from the stack
            if (blockStack.length > 0) {
                blockStack.pop();
            }
            skipToken()
        } else {
            // Parse other instructions (local.get, i32.add, etc.)
            const instr = parseInstruction(blockLabels);

            // Add the instruction to the current block or function body
            if (blockStack.length > 0) {
                const currentBlock = blockStack[blockStack.length - 1];
                if (currentBlock.type === 'if') {
                    if (currentBlock.inElseBranch) {
                        currentBlock.elseInstructions.push(instr);
                    } else {
                        currentBlock.thenInstructions.push(instr);
                    }
                } else {
                    // For blocks and loops
                    currentBlock.instructions.push(instr);
                }
            } else {
                // Add to main function body
                instructions.push(instr);
            }
        }
    }

    // Return function object with additional inline export information
    const func = {
        name: name,
        parameters: params,
        locals: locals,
        results: results,
        instructions: instructions,
        typeRef: typeRef  // Include the type reference if present
    };

    // Generated by 
    // If this function has an inline export, include it in the return value
    if (exportName) {
        func.export = exportName;
    }

    // If this function has an import, include it in the return value
    if (importInfo) {
        func.import = importInfo;
    }

    return func;
}