import { tokenize } from '../tokenize.mjs';
import { initTape, atEnd } from './tape.mjs';
import { parseExpression } from './parse-expression.mjs';

export function parseWAT(src) {
    const tokens = tokenize(src);
    const sourceMap = tokens.sourceMap || new Map();

    initTape(tokens, sourceMap);

    // Start parsing from the beginning of the tokens
    const ast = [];
    while (!atEnd()) {
        const expr = parseExpression();
        if (expr !== null) {
            ast.push(expr);
        }
    }

    function applyTypeRefToFunction(func, module) {
        // Generated by ðŸ¤–
        // If function has a type reference, apply the referenced type's params and results
        if (func.typeRef && module && module.types) {
            const typeEntry = module.types.find(type => type.name === func.typeRef);

            if (typeEntry) {
                // For functions with type references, update their parameters
                // Only overwrite if the function doesn't already have params/results
                if (func.parameters.length === 0 && typeEntry.params.length > 0) {
                    func.parameters = typeEntry.params.map((type, index) => ({
                        name: index.toString(), // Use index as name for parameters
                        type
                    }));
                }

                if (func.results.length === 0 && typeEntry.results.length > 0) {
                    func.results = [...typeEntry.results];
                }
            }
        }

        return func;
    }

    // Resolve function and global exports
    for (const moduleObj of ast) {
        if (moduleObj && typeof moduleObj === 'object') {
            // Apply type references to functions
            if (moduleObj.functions && moduleObj.functions.length > 0) {
                moduleObj.functions = moduleObj.functions.map(func =>
                    applyTypeRefToFunction(func, moduleObj));
            }

            // Resolve exports
            if (moduleObj.exports) {
                for (const [exportName, exportData] of Object.entries(moduleObj.exports)) {
                    if (exportData.kind === 'func' && typeof exportData.index === 'string' && exportData.index.startsWith('$')) {
                        // Find the function by name
                        const funcIndex = moduleObj.functions.findIndex(func => func.name === exportData.index);
                        if (funcIndex !== -1) {
                            exportData.index = funcIndex;
                        }
                    } else if (exportData.kind === 'global' && typeof exportData.index === 'string' && exportData.index.startsWith('$')) {
                        // Find the global by name
                        const globalIndex = moduleObj.globals.findIndex(global => global.name === exportData.index);
                        if (globalIndex !== -1) {
                            exportData.index = globalIndex;
                        }
                    } else if (exportData.kind === 'table' && typeof exportData.index === 'string' && exportData.index.startsWith('$')) {
                        // Find the table by name
                        const tableIndex = moduleObj.tables.findIndex(table => table.id === exportData.index);
                        if (tableIndex !== -1) {
                            exportData.index = tableIndex;
                        }
                    } else if (exportData.kind === 'memory' && typeof exportData.index === 'string' && exportData.index.startsWith('$')) {
                        // Generated by ðŸ¤–
                        // Find the memory by name
                        const memoryIndex = moduleObj.memories.findIndex(memory => memory.id === exportData.index);
                        if (memoryIndex !== -1) {
                            exportData.index = memoryIndex;
                        }
                    }
                }
            }
        }
    }

    return ast;
}
