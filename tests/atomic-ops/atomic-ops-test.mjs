import { readTestData } from "../test-utils.mjs";

async function testAtomicOps(debug = true) {
    try {
        const { wasmBuffer } = await readTestData("atomic-ops/atomic-ops.wat", debug);

        // Instantiate the WebAssembly module
        const { instance } = await WebAssembly.instantiate(wasmBuffer);

        // Test atomic operations
        const testCases = [
            {
                name: "i32.atomic.rmw.add - basic operation",
                test: () => {
                    const address = 0;
                    // Initialize memory with value 10
                    instance.exports.store(address, 10);
                    // Add 5 atomically and get the previous value
                    const previousValue = instance.exports.atomicAdd(address, 5);
                    // Check that the previous value was returned
                    const expectedPrevious = 10;
                    // Check that the new value is properly stored
                    const newValue = instance.exports.load(address);
                    const expectedNew = 15;

                    return (
                        previousValue === expectedPrevious &&
                        newValue === expectedNew
                    );
                }
            },
            {
                name: "i32.atomic.rmw.add - adding zero",
                test: () => {
                    const address = 4; // Different address to avoid interference
                    instance.exports.store(address, 42);
                    const previousValue = instance.exports.atomicAdd(address, 0);
                    const newValue = instance.exports.load(address);

                    return previousValue === 42 && newValue === 42;
                }
            },
            {
                name: "i32.atomic.rmw.add - adding negative value",
                test: () => {
                    const address = 8;
                    instance.exports.store(address, 50);
                    const previousValue = instance.exports.atomicAdd(address, -20);
                    const newValue = instance.exports.load(address);

                    return previousValue === 50 && newValue === 30;
                }
            },
            {
                name: "i32.atomic.rmw.add - overflow behavior",
                test: () => {
                    const address = 12;
                    // Max i32 value
                    const maxI32 = 2147483647;
                    instance.exports.store(address, maxI32);
                    const previousValue = instance.exports.atomicAdd(address, 1);
                    const newValue = instance.exports.load(address);

                    // Adding 1 to max i32 should overflow to -2147483648
                    return previousValue === maxI32 && newValue === -2147483648;
                }
            },
            // i64 atomic tests
            {
                name: "i64.atomic.rmw.add - basic operation",
                test: () => {
                    const address = 16;
                    // Initialize memory with value 10n
                    instance.exports.store64(address, 10n);
                    // Add 5 atomically and get the previous value
                    const previousValue = instance.exports.atomicAdd64(address, 5n);
                    // Check that the previous value was returned
                    const expectedPrevious = 10n;
                    // Check that the new value is properly stored
                    const newValue = instance.exports.load64(address);
                    const expectedNew = 15n;

                    return (
                        previousValue === expectedPrevious &&
                        newValue === expectedNew
                    );
                }
            },
            {
                name: "i64.atomic.rmw.add - overflow behavior",
                test: () => {
                    const address = 24;
                    // Max i64 value
                    const maxI64 = 9223372036854775807n;
                    instance.exports.store64(address, maxI64);
                    const previousValue = instance.exports.atomicAdd64(address, 1n);
                    const newValue = instance.exports.load64(address);

                    // Adding 1 to max i64 should overflow to -9223372036854775808n
                    return previousValue === maxI64 && newValue === -9223372036854775808n;
                }
            },
            // Generated by 🤖
            // Tests for the new 8-bit, 16-bit and 32-bit atomic RMW operations
            {
                name: "i32.atomic.rmw8.add_u - basic operation",
                test: () => {
                    const address = 32;
                    // Initialize with a value that will overflow 8 bits
                    instance.exports.store(address, 0x00000080);
                    const previousValue = instance.exports.atomicAdd8(address, 0x01);
                    const newValue = instance.exports.load(address);
                    
                    // Previous value should be 0x80 (128), after adding becomes 0x81 (129),
                    // but since it's 8-bit, we only look at the bottom 8 bits (0x81 = 129)
                    return previousValue === 0x80 && (newValue & 0xFF) === 0x81;
                }
            },
            {
                name: "i32.atomic.rmw8.add_u - overflow behavior",
                test: () => {
                    const address = 36;
                    // Initialize with 0xFF (max 8-bit value)
                    instance.exports.store(address, 0xFF);
                    const previousValue = instance.exports.atomicAdd8(address, 0x01);
                    const newValue = instance.exports.load(address);
                    
                    // 0xFF + 1 = 0x100, but since it's 8-bit unsigned, it wraps to 0x00
                    return previousValue === 0xFF && (newValue & 0xFF) === 0x00;
                }
            },
            {
                name: "i32.atomic.rmw16.add_u - basic operation",
                test: () => {
                    const address = 40;
                    // Initialize with a value
                    instance.exports.store(address, 0x0000ABCD);
                    const previousValue = instance.exports.atomicAdd16(address, 0x0001);
                    const newValue = instance.exports.load(address);
                    
                    // Previous value should be 0xABCD (43981), after adding becomes 0xABCE (43982)
                    // but since it's 16-bit, we only look at the bottom 16 bits
                    return previousValue === 0xABCD && (newValue & 0xFFFF) === 0xABCE;
                }
            },
            {
                name: "i64.atomic.rmw8.add_u - basic operation",
                test: () => {
                    const address = 44;
                    // Initialize with a value
                    instance.exports.store64(address, 0x8000000000000080n);
                    const previousValue = instance.exports.atomicAdd8_64(address, 0x01n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0x80 (bottom 8 bits), after adding becomes 0x81
                    return previousValue === 0x80n && (newValue & 0xFFn) === 0x81n;
                }
            },
            {
                name: "i64.atomic.rmw16.add_u - basic operation",
                test: () => {
                    const address = 52;
                    // Initialize with a value
                    instance.exports.store64(address, 0x800000000000BEEFn);
                    const previousValue = instance.exports.atomicAdd16_64(address, 0x0001n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0xBEEF (bottom 16 bits), after adding becomes 0xBEF0
                    return previousValue === 0xBEEFn && (newValue & 0xFFFFn) === 0xBEF0n;
                }
            },
            {
                name: "i64.atomic.rmw32.add_u - basic operation",
                test: () => {
                    const address = 60;
                    // Initialize with a value
                    instance.exports.store64(address, 0x80000000DEADBEEFn);
                    const previousValue = instance.exports.atomicAdd32_64(address, 0x00000001n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous should be 0xDEADBEEF (bottom 32 bits), after adding becomes 0xDEADBEF0
                    return previousValue === 0xDEADBEEFn && (newValue & 0xFFFFFFFFn) === 0xDEADBEF0n;
                }
            },
            // Generated by 🤖
            // Tests for the atomic RMW sub_u operations
            {
                name: "i32.atomic.rmw8.sub_u - basic operation",
                test: () => {
                    const address = 150;
                    // Initialize with 0x80
                    instance.exports.store(address, 0x80);
                    const previousValue = instance.exports.atomicSub8(address, 0x01);
                    const newValue = instance.exports.load(address);
                    
                    // Previous should be 0x80, after subtracting 1 becomes 0x7F
                    return previousValue === 0x80 && (newValue & 0xFF) === 0x7F;
                }
            },
            {
                name: "i32.atomic.rmw8.sub_u - underflow behavior",
                test: () => {
                    const address = 154;
                    // Initialize with 0x00
                    instance.exports.store(address, 0x00);
                    const previousValue = instance.exports.atomicSub8(address, 0x01);
                    const newValue = instance.exports.load(address);
                    
                    // Previous should be 0x00, after subtracting 1 wraps to 0xFF in 8-bit unsigned
                    return previousValue === 0x00 && (newValue & 0xFF) === 0xFF;
                }
            },
            {
                name: "i32.atomic.rmw16.sub_u - basic operation",
                test: () => {
                    const address = 158; // Ensure 2-byte alignment (158 is already even)
                    // Initialize with 0xABCD
                    instance.exports.store(address, 0xABCD);
                    const previousValue = instance.exports.atomicSub16(address, 0x0001);
                    const newValue = instance.exports.load(address);
                    
                    // Previous should be 0xABCD, after subtracting becomes 0xABCC
                    return previousValue === 0xABCD && (newValue & 0xFFFF) === 0xABCC;
                }
            },
            {
                name: "i64.atomic.rmw8.sub_u - basic operation",
                test: () => {
                    const address = 162; // 1-byte align is any address
                    // Initialize with a value
                    instance.exports.store64(address, 0x8000000000000080n);
                    const previousValue = instance.exports.atomicSub8_64(address, 0x01n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous should be 0x80, after subtracting becomes 0x7F
                    return previousValue === 0x80n && (newValue & 0xFFn) === 0x7Fn;
                }
            },
            {
                name: "i64.atomic.rmw16.sub_u - basic operation",
                test: () => {
                    const address = 170; // Ensure 2-byte alignment (170 is already even)
                    // Initialize with a value
                    instance.exports.store64(address, 0x800000000000BEEFn);
                    const previousValue = instance.exports.atomicSub16_64(address, 0x0001n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous should be 0xBEEF, after subtracting becomes 0xBEEE
                    return previousValue === 0xBEEFn && (newValue & 0xFFFFn) === 0xBEEEn;
                }
            },
            {
                name: "i64.atomic.rmw32.sub_u - basic operation",
                test: () => {
                    const address = 176; // Fixed: Ensure 4-byte alignment (176 is divisible by 4)
                    // Initialize with a value
                    instance.exports.store64(address, 0x80000000DEADBEEFn);
                    const previousValue = instance.exports.atomicSub32_64(address, 0x00000001n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous should be 0xDEADBEEF, after subtracting becomes 0xDEADBEEE
                    return previousValue === 0xDEADBEEFn && (newValue & 0xFFFFFFFFn) === 0xDEADBEEEn;
                }
            },
            // Generated by 🤖
            // Tests for the atomic RMW AND unsigned operations
            {
                name: "i32.atomic.rmw8.and_u - basic operation",
                test: () => {
                    const address = 184; // 1-byte align is any address
                    // Initialize with 0xF0
                    instance.exports.store(address, 0xF0);
                    const previousValue = instance.exports.atomicAnd8(address, 0x0F);
                    const newValue = instance.exports.load(address);
                    
                    // 0xF0 & 0x0F = 0x00
                    return previousValue === 0xF0 && (newValue & 0xFF) === 0x00;
                }
            },
            {
                name: "i32.atomic.rmw16.and_u - basic operation",
                test: () => {
                    const address = 188; // Ensure 2-byte alignment
                    // Initialize with 0xF0F0
                    instance.exports.store(address, 0xF0F0);
                    const previousValue = instance.exports.atomicAnd16(address, 0x0F0F);
                    const newValue = instance.exports.load(address);
                    
                    // 0xF0F0 & 0x0F0F = 0x0000
                    return previousValue === 0xF0F0 && (newValue & 0xFFFF) === 0x0000;
                }
            },
            {
                name: "i64.atomic.rmw8.and_u - basic operation",
                test: () => {
                    const address = 192;
                    // Initialize with a value
                    instance.exports.store64(address, 0x00000000000000FFn);
                    const previousValue = instance.exports.atomicAnd8_64(address, 0x0Fn);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xFF & 0x0F = 0x0F
                    return previousValue === 0xFFn && (newValue & 0xFFn) === 0x0Fn;
                }
            },
            {
                name: "i64.atomic.rmw16.and_u - basic operation",
                test: () => {
                    const address = 200; // Ensure 2-byte alignment
                    // Initialize with a value
                    instance.exports.store64(address, 0x000000000000FFFFn);
                    const previousValue = instance.exports.atomicAnd16_64(address, 0xFF00n);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xFFFF & 0xFF00 = 0xFF00
                    return previousValue === 0xFFFFn && (newValue & 0xFFFFn) === 0xFF00n;
                }
            },
            {
                name: "i64.atomic.rmw32.and_u - basic operation",
                test: () => {
                    const address = 208; // Ensure 4-byte alignment
                    // Initialize with a value
                    instance.exports.store64(address, 0x00000000FFFFFFFFn);
                    const previousValue = instance.exports.atomicAnd32_64(address, 0xFFFF0000n);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xFFFFFFFF & 0xFFFF0000 = 0xFFFF0000
                    return previousValue === 0xFFFFFFFFn && (newValue & 0xFFFFFFFFn) === 0xFFFF0000n;
                }
            },
            // i32 atomic sub tests
            {
                name: "i32.atomic.rmw.sub - basic operation",
                test: () => {
                    const address = 64;
                    instance.exports.store(address, 50);
                    const previousValue = instance.exports.atomicSub(address, 20);
                    const newValue = instance.exports.load(address);

                    return previousValue === 50 && newValue === 30;
                }
            },
            // i32 atomic and tests
            {
                name: "i32.atomic.rmw.and - basic operation",
                test: () => {
                    const address = 68;
                    instance.exports.store(address, 0b1010);
                    const previousValue = instance.exports.atomicAnd32(address, 0b1100);
                    const newValue = instance.exports.load(address);

                    return previousValue === 0b1010 && newValue === 0b1000;
                }
            },
            // i32 atomic or tests
            {
                name: "i32.atomic.rmw.or - basic operation",
                test: () => {
                    const address = 72;
                    instance.exports.store(address, 0b1010);
                    const previousValue = instance.exports.atomicOr32(address, 0b0101);
                    const newValue = instance.exports.load(address);

                    return previousValue === 0b1010 && newValue === 0b1111;
                }
            },
            // i32 atomic xor tests
            {
                name: "i32.atomic.rmw.xor - basic operation",
                test: () => {
                    const address = 76;
                    instance.exports.store(address, 0b1010);
                    const previousValue = instance.exports.atomicXor32(address, 0b1100);
                    const newValue = instance.exports.load(address);

                    return previousValue === 0b1010 && newValue === 0b0110;
                }
            },
            // i32 atomic exchange tests
            {
                name: "i32.atomic.rmw.xchg - basic operation",
                test: () => {
                    const address = 80;
                    instance.exports.store(address, 42);
                    const previousValue = instance.exports.atomicXchg32(address, 99);
                    const newValue = instance.exports.load(address);

                    return previousValue === 42 && newValue === 99;
                }
            },
            // i32 atomic compare exchange tests
            {
                name: "i32.atomic.rmw.cmpxchg - successful exchange",
                test: () => {
                    const address = 84;
                    instance.exports.store(address, 42);
                    const previousValue = instance.exports.atomicCmpxchg32(address, 42, 99);
                    const newValue = instance.exports.load(address);

                    return previousValue === 42 && newValue === 99;
                }
            },
            {
                name: "i32.atomic.rmw.cmpxchg - failed exchange",
                test: () => {
                    const address = 88;
                    instance.exports.store(address, 42);
                    const previousValue = instance.exports.atomicCmpxchg32(address, 43, 99);
                    const newValue = instance.exports.load(address);

                    return previousValue === 42 && newValue === 42; // No change when expected doesn't match
                }
            },
            // i64 atomic sub tests
            {
                name: "i64.atomic.rmw.sub - basic operation",
                test: () => {
                    const address = 96;
                    instance.exports.store64(address, 100n);
                    const previousValue = instance.exports.atomicSub64(address, 40n);
                    const newValue = instance.exports.load64(address);

                    return previousValue === 100n && newValue === 60n;
                }
            },
            // i64 atomic and tests
            {
                name: "i64.atomic.rmw.and - basic operation",
                test: () => {
                    const address = 104;
                    instance.exports.store64(address, 0b1010n);
                    const previousValue = instance.exports.atomicAnd64(address, 0b1100n);
                    const newValue = instance.exports.load64(address);

                    return previousValue === 0b1010n && newValue === 0b1000n;
                }
            },
            // i64 atomic or tests
            {
                name: "i64.atomic.rmw.or - basic operation",
                test: () => {
                    const address = 112;
                    instance.exports.store64(address, 0b1010n);
                    const previousValue = instance.exports.atomicOr64(address, 0b0101n);
                    const newValue = instance.exports.load64(address);

                    return previousValue === 0b1010n && newValue === 0b1111n;
                }
            },
            // i64 atomic xor tests
            {
                name: "i64.atomic.rmw.xor - basic operation",
                test: () => {
                    const address = 120;
                    instance.exports.store64(address, 0b1010n);
                    const previousValue = instance.exports.atomicXor64(address, 0b1100n);
                    const newValue = instance.exports.load64(address);

                    return previousValue === 0b1010n && newValue === 0b0110n;
                }
            },
            // i64 atomic exchange tests
            {
                name: "i64.atomic.rmw.xchg - basic operation",
                test: () => {
                    const address = 128;
                    instance.exports.store64(address, 42n);
                    const previousValue = instance.exports.atomicXchg64(address, 99n);
                    const newValue = instance.exports.load64(address);

                    return previousValue === 42n && newValue === 99n;
                }
            },
            // i64 atomic compare exchange tests
            {
                name: "i64.atomic.rmw.cmpxchg - successful exchange",
                test: () => {
                    const address = 136;
                    instance.exports.store64(address, 42n);
                    const previousValue = instance.exports.atomicCmpxchg64(address, 42n, 99n);
                    const newValue = instance.exports.load64(address);

                    return previousValue === 42n && newValue === 99n;
                }
            },
            {
                name: "i64.atomic.rmw.cmpxchg - failed exchange",
                test: () => {
                    const address = 144;
                    instance.exports.store64(address, 42n);
                    const previousValue = instance.exports.atomicCmpxchg64(address, 43n, 99n);
                    const newValue = instance.exports.load64(address);

                    return previousValue === 42n && newValue === 42n; // No change when expected doesn't match
                }
            },
            // Tests for atomic OR 8-bit, 16-bit and 32-bit operations
            {
                name: "i32.atomic.rmw8.or_u - basic operation",
                test: () => {
                    const address = 300;
                    instance.exports.store(address, 0x0F);
                    const previousValue = instance.exports.atomicOr8(address, 0xF0);
                    const newValue = instance.exports.load(address);
                    
                    // 0x0F | 0xF0 = 0xFF
                    return previousValue === 0x0F && (newValue & 0xFF) === 0xFF;
                }
            },
            {
                name: "i32.atomic.rmw16.or_u - basic operation",
                test: () => {
                    const address = 304; // Ensure 2-byte alignment
                    instance.exports.store(address, 0x0F0F);
                    const previousValue = instance.exports.atomicOr16(address, 0xF0F0);
                    const newValue = instance.exports.load(address);
                    
                    // 0x0F0F | 0xF0F0 = 0xFFFF
                    return previousValue === 0x0F0F && (newValue & 0xFFFF) === 0xFFFF;
                }
            },
            {
                name: "i64.atomic.rmw8.or_u - basic operation",
                test: () => {
                    const address = 308;
                    instance.exports.store64(address, 0x00000000000000F0n);
                    const previousValue = instance.exports.atomicOr8_64(address, 0x0Fn);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xF0 | 0x0F = 0xFF
                    return previousValue === 0xF0n && (newValue & 0xFFn) === 0xFFn;
                }
            },
            {
                name: "i64.atomic.rmw16.or_u - basic operation",
                test: () => {
                    const address = 312; // Ensure 2-byte alignment
                    instance.exports.store64(address, 0x000000000000F0F0n);
                    const previousValue = instance.exports.atomicOr16_64(address, 0x0F0Fn);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xF0F0 | 0x0F0F = 0xFFFF
                    return previousValue === 0xF0F0n && (newValue & 0xFFFFn) === 0xFFFFn;
                }
            },
            {
                name: "i64.atomic.rmw32.or_u - basic operation",
                test: () => {
                    const address = 316; // Ensure 4-byte alignment
                    instance.exports.store64(address, 0x00000000F0F0F0F0n);
                    const previousValue = instance.exports.atomicOr32_64(address, 0x0F0F0F0Fn);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xF0F0F0F0 | 0x0F0F0F0F = 0xFFFFFFFF
                    return previousValue === 0xF0F0F0F0n && (newValue & 0xFFFFFFFFn) === 0xFFFFFFFFn;
                }
            },
            // Tests for atomic XOR operations
            {
                name: "i32.atomic.rmw8.xor_u - basic operation",
                test: () => {
                    const address = 320;
                    instance.exports.store(address, 0xFF);
                    const previousValue = instance.exports.atomicXor8(address, 0xAA);
                    const newValue = instance.exports.load(address);
                    
                    // 0xFF ^ 0xAA = 0x55
                    return previousValue === 0xFF && (newValue & 0xFF) === 0x55;
                }
            },
            {
                name: "i32.atomic.rmw16.xor_u - basic operation",
                test: () => {
                    const address = 324; // Ensure 2-byte alignment
                    instance.exports.store(address, 0xFFFF);
                    const previousValue = instance.exports.atomicXor16(address, 0xAAAA);
                    const newValue = instance.exports.load(address);
                    
                    // 0xFFFF ^ 0xAAAA = 0x5555
                    return previousValue === 0xFFFF && (newValue & 0xFFFF) === 0x5555;
                }
            },
            {
                name: "i64.atomic.rmw8.xor_u - basic operation",
                test: () => {
                    const address = 328;
                    instance.exports.store64(address, 0x00000000000000FFn);
                    const previousValue = instance.exports.atomicXor8_64(address, 0xAAn);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xFF ^ 0xAA = 0x55
                    return previousValue === 0xFFn && (newValue & 0xFFn) === 0x55n;
                }
            },
            {
                name: "i64.atomic.rmw16.xor_u - basic operation",
                test: () => {
                    const address = 332; // Ensure 2-byte alignment
                    instance.exports.store64(address, 0x000000000000FFFFn);
                    const previousValue = instance.exports.atomicXor16_64(address, 0xAAAAn);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xFFFF ^ 0xAAAA = 0x5555
                    return previousValue === 0xFFFFn && (newValue & 0xFFFFn) === 0x5555n;
                }
            },
            {
                name: "i64.atomic.rmw32.xor_u - basic operation",
                test: () => {
                    const address = 336; // Ensure 4-byte alignment
                    instance.exports.store64(address, 0x00000000FFFFFFFFn);
                    const previousValue = instance.exports.atomicXor32_64(address, 0xAAAAAAAAn);
                    const newValue = instance.exports.load64(address);
                    
                    // 0xFFFFFFFF ^ 0xAAAAAAAA = 0x55555555
                    return previousValue === 0xFFFFFFFFn && (newValue & 0xFFFFFFFFn) === 0x55555555n;
                }
            },
            // Tests for atomic exchange operations
            {
                name: "i32.atomic.rmw8.xchg_u - basic operation",
                test: () => {
                    const address = 340;
                    instance.exports.store(address, 0x42);
                    const previousValue = instance.exports.atomicXchg8(address, 0x99);
                    const newValue = instance.exports.load(address);
                    
                    // Previous value should be 0x42, new value should be 0x99
                    return previousValue === 0x42 && (newValue & 0xFF) === 0x99;
                }
            },
            {
                name: "i32.atomic.rmw16.xchg_u - basic operation",
                test: () => {
                    const address = 344; // Ensure 2-byte alignment
                    instance.exports.store(address, 0x4242);
                    const previousValue = instance.exports.atomicXchg16(address, 0x9999);
                    const newValue = instance.exports.load(address);
                    
                    // Previous value should be 0x4242, new value should be 0x9999
                    return previousValue === 0x4242 && (newValue & 0xFFFF) === 0x9999;
                }
            },
            {
                name: "i64.atomic.rmw8.xchg_u - basic operation",
                test: () => {
                    const address = 348;
                    instance.exports.store64(address, 0x0000000000000042n);
                    const previousValue = instance.exports.atomicXchg8_64(address, 0x99n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0x42, new value should be 0x99
                    return previousValue === 0x42n && (newValue & 0xFFn) === 0x99n;
                }
            },
            {
                name: "i64.atomic.rmw16.xchg_u - basic operation",
                test: () => {
                    const address = 352; // Ensure 2-byte alignment
                    instance.exports.store64(address, 0x0000000000004242n);
                    const previousValue = instance.exports.atomicXchg16_64(address, 0x9999n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0x4242, new value should be 0x9999
                    return previousValue === 0x4242n && (newValue & 0xFFFFn) === 0x9999n;
                }
            },
            {
                name: "i64.atomic.rmw32.xchg_u - basic operation",
                test: () => {
                    const address = 356; // Ensure 4-byte alignment
                    instance.exports.store64(address, 0x0000000042424242n);
                    const previousValue = instance.exports.atomicXchg32_64(address, 0x99999999n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0x42424242, new value should be 0x99999999
                    return previousValue === 0x42424242n && (newValue & 0xFFFFFFFFn) === 0x99999999n;
                }
            },
            // Tests for atomic compare-exchange operations
            {
                name: "i32.atomic.rmw8.cmpxchg_u - successful exchange",
                test: () => {
                    const address = 360;
                    instance.exports.store(address, 0xAB);
                    const previousValue = instance.exports.atomicCmpxchg8(address, 0xAB, 0xCD);
                    const newValue = instance.exports.load(address);
                    
                    // Previous value should be 0xAB, new value should be 0xCD
                    return previousValue === 0xAB && (newValue & 0xFF) === 0xCD;
                }
            },
            {
                name: "i32.atomic.rmw8.cmpxchg_u - failed exchange",
                test: () => {
                    const address = 364;
                    instance.exports.store(address, 0xAB);
                    const previousValue = instance.exports.atomicCmpxchg8(address, 0xAC, 0xCD); // Expected doesn't match
                    const newValue = instance.exports.load(address);
                    
                    // Previous value should be 0xAB, value should remain 0xAB (no change)
                    return previousValue === 0xAB && (newValue & 0xFF) === 0xAB;
                }
            },
            {
                name: "i32.atomic.rmw16.cmpxchg_u - successful exchange",
                test: () => {
                    const address = 368; // Ensure 2-byte alignment
                    instance.exports.store(address, 0xABCD);
                    const previousValue = instance.exports.atomicCmpxchg16(address, 0xABCD, 0x1234);
                    const newValue = instance.exports.load(address);
                    
                    // Previous value should be 0xABCD, new value should be 0x1234
                    return previousValue === 0xABCD && (newValue & 0xFFFF) === 0x1234;
                }
            },
            {
                name: "i64.atomic.rmw8.cmpxchg_u - successful exchange",
                test: () => {
                    const address = 372;
                    instance.exports.store64(address, 0x00000000000000ABn);
                    const previousValue = instance.exports.atomicCmpxchg8_64(address, 0xABn, 0xCDn);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0xAB, new value should be 0xCD
                    return previousValue === 0xABn && (newValue & 0xFFn) === 0xCDn;
                }
            },
            {
                name: "i64.atomic.rmw16.cmpxchg_u - successful exchange",
                test: () => {
                    const address = 376; // Ensure 2-byte alignment
                    instance.exports.store64(address, 0x000000000000ABCDn);
                    const previousValue = instance.exports.atomicCmpxchg16_64(address, 0xABCDn, 0x1234n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0xABCD, new value should be 0x1234
                    return previousValue === 0xABCDn && (newValue & 0xFFFFn) === 0x1234n;
                }
            },
            {
                name: "i64.atomic.rmw32.cmpxchg_u - successful exchange",
                test: () => {
                    const address = 380; // Ensure 4-byte alignment
                    instance.exports.store64(address, 0x00000000ABCDEF01n);
                    const previousValue = instance.exports.atomicCmpxchg32_64(address, 0xABCDEF01n, 0x12345678n);
                    const newValue = instance.exports.load64(address);
                    
                    // Previous value should be 0xABCDEF01, new value should be 0x12345678
                    return previousValue === 0xABCDEF01n && (newValue & 0xFFFFFFFFn) === 0x12345678n;
                }
            }
        ];

        let allPassed = true;
        for (const test of testCases) {
            const passed = test.test();
            console.log(`${passed ? '✅' : '❌'} ${test.name}`);
            if (!passed) allPassed = false;
        }

        // atomic fence test
        const { wasmBuffer: atomicFenceBuffer } = await readTestData("atomic-ops/atomic-fence.wat", debug);
        const { instance: atomicFenceInstance } = await WebAssembly.instantiate(atomicFenceBuffer);
        try {
            const result = atomicFenceInstance.exports.use_fence();
            if (result !== 42) {
                console.log(`❌ atomic.fence test failed: expected 42, got ${result}`);
                allPassed = false;
            } else {
                console.log(`✅ atomic.fence test passed`);
            }
        } catch (error) {
            console.error(`❌ atomic.fence test error:`, error);
            allPassed = false;
        }  // Generated by 🤖

        if (allPassed) {
            console.log('✅ All atomic memory tests passed!');
            return true;
        } else {
            console.error('❌ Some atomic memory tests failed!');
            return false;
        }
    } catch (error) {
        console.error("Error during WebAssembly instantiation or execution:", error);
        return false;
    }
}

export default testAtomicOps;