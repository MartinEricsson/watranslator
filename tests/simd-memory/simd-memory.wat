(module
  ;; Define a memory section with 1 page (64KB)
  (memory 1)

  ;; Export the memory
  (export "memory" (memory 0))

  ;; Initialize memory with test data
  (data (i32.const 0)
    ;; 16 bytes of sequential data for testing v128 operations
    "\00\01\02\03\04\05\06\07\08\09\0A\0B\0C\0D\0E\0F"
    ;; Additional 16 bytes with alternating values
    "\AA\BB\CC\DD\EE\FF\AA\BB\CC\DD\EE\FF\AA\BB\CC\DD"
  )

  ;; Basic v128.load test
  (func (export "test_v128_load") (result i32)
    ;; Load v128 from memory address 0
    i32.const 0
    v128.load
    
    ;; Extract first lane to verify the load worked
    i8x16.extract_lane_u 0
  )

  ;; Offset and alignment test for v128.load
  (func (export "test_v128_load_offset") (result i32)
    ;; Load v128 from effective address 16 (base + offset)
    i32.const 0
    v128.load offset=16
    
    ;; Extract first lane to verify (should be 0xAA)
    i8x16.extract_lane_u 0
  )

  ;; Test v128.store and then v128.load to verify
  (func (export "test_v128_store") (result i32)
    ;; Store it at address 32
    i32.const 32
    
    ;; Create a test vector with all lanes set to 0x42
    v128.const i8x16 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42 0x42
    
    v128.store
    
    ;; Load it back
    i32.const 32
    v128.load
    
    ;; Extract a lane to verify (should be 0x42)
    i8x16.extract_lane_u 0
  )

  ;; Test v128.load8_splat
  (func (export "test_v128_load8_splat") (result i32)
    ;; Load a single byte (0x03) from offset 3 and splat across all lanes
    i32.const 0
    v128.load8_splat offset=3
    
    ;; Extract lane 15 (should also be 0x03)
    i8x16.extract_lane_u 15
  )

  ;; Test v128.load16_splat
  (func (export "test_v128_load16_splat") (result i32)
    ;; Load a 16-bit value (0x0102) from offset 1 and splat across all lanes
    i32.const 0
    v128.load16_splat offset=1
    
    ;; Extract first lane as 16-bit and truncate to return i32
    i16x8.extract_lane_u 0
  )

  ;; Test v128.load32_splat
  (func (export "test_v128_load32_splat") (result i32)
    ;; Load a 32-bit value from offset 0 and splat across all lanes
    i32.const 0
    v128.load32_splat
    
    ;; Extract first lane (should be 0x03020100)
    i32x4.extract_lane 0
  )

  ;; Test v128.load64_splat
  (func (export "test_v128_load64_splat") (result i64)
    ;; Load a 64-bit value from offset 0 and splat across all lanes
    i32.const 0
    v128.load64_splat
    
    ;; Extract first lane (should be 0x0706050403020100)
    i64x2.extract_lane 0
  )

  ;; Test lane-based load operation
  (func (export "test_v128_load8_lane") (result i32)
    ;; Load byte from memory at offset 5 into lane 10
    i32.const 0
    
    ;; Create initial vector with zeros
    v128.const i8x16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    
    v128.load8_lane offset=5 10
    
    ;; Extract the modified lane (should be 0x05)
    i8x16.extract_lane_u 10
  )

  ;; Test lane-based store operation
  (func (export "test_v128_store8_lane") (result i32)
    ;; Store byte from lane 7 to memory at offset 40
    i32.const 0
    
    ;; Create vector with specific value in lane 7
    v128.const i8x16 0 0 0 0 0 0 0 0x42 0 0 0 0 0 0 0 0
    
    v128.store8_lane offset=40 7
    
    ;; Load the stored byte as i32 (should be 0x42)
    i32.const 40
    i32.load8_u
  )

  ;; Test v128.load32_zero (loads 32-bits and zero-extends to 128-bits)
  (func (export "test_v128_load32_zero") (result i32)
    ;; Load a 32-bit value from offset 0 and zero-extend
    i32.const 0
    v128.load32_zero
    
    ;; Extract first lane (should contain the value)
    i32x4.extract_lane 0
  )

  ;; Test load with sign extension: v128.load8x8_s
  (func (export "test_v128_load8x8_s") (result i32)
    ;; Load 8 bytes and sign-extend each to 16-bits
    i32.const 0
    v128.load8x8_s
    
    ;; Check the sign extension by extracting a lane with a high bit set
    ;; Byte 0x0F (15) at index 15 when sign-extended to 16-bits remains 15
    i16x8.extract_lane_s 7
  )
)
;; Generated by ðŸ¤–
