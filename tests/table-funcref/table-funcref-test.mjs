// Generated by ü§ñ
import assert from 'assert';

import { readTestData } from '../test-utils.mjs';

async function testTableFuncref(debug = false) {
  try {
    const { wasmBuffer, ast } = await readTestData('table-funcref/table-funcref.wat', debug);

    const { instance } = await WebAssembly.instantiate(wasmBuffer, {});

    // Check that the table was properly parsed
    const tablesExists = ast[0].tables && ast[0].tables.length > 0;
    if (tablesExists) {
      console.log('‚úÖ Table found in AST:', ast[0].tables);
    } else {
      console.error('‚ùå Table not found in AST');
    }
    // Verify table properties
    const tableproperties = ast[0].tables[0].min === 2 && ast[0].tables[0].max === 4 && ast[0].tables[0].type === 'funcref';
    if (tableproperties) {
      console.log('‚úÖ Table properties verified:', ast[0].tables[0]);
    } else {
      console.error('‚ùå Table properties verification failed');
    }

    // Verify functions that will be referenced by table
    const funtionReferencesCheck = ast[0].functions.length >= 2 && ast[0].functions[0].name === '$f1' && ast[0].functions[1].name === '$f2';
    if (funtionReferencesCheck) {
      console.log('‚úÖ Function references verified:', ast[0].functions);
    } else {
      console.error('‚ùå Function references verification failed');
    }

    // Verify element section is present and properly initialized
    assert(ast[0].elements && ast[0].elements.length > 0, 'Element section should be present');
    const elem = ast[0].elements[0];
    assert.strictEqual(elem.offset, 0, 'Element segment offset should be 0');
    assert.strictEqual(elem.functionIndices[0], '$f1', 'First function reference should be $f1');
    assert.strictEqual(elem.functionIndices[1], '$f2', 'Second function reference should be $f2');

    // Verify export is present
    assert(ast[0].exports && ast[0].exports.tbl, 'Table export should be present');
    assert.strictEqual(ast[0].exports.tbl.kind, 'table', 'Export kind should be "table"');

    // Check that the table is properly exported
    assert(instance.exports.tbl instanceof WebAssembly.Table, 'Table should be exported as WebAssembly.Table');
    assert.strictEqual(instance.exports.tbl.length, 2, 'Table should have length 2');

    const tests = [
      { name: "f1", expected: 42, func: 'f1', params: [] },
      { name: "f2", expected: 43, func: 'f2', params: [] },
      { name: "tableSize", expected: 2, func: 'tableSize', params: [] },
    ];

    let results = [];

    for (const { name, expected, func, params } of tests) {
      let result = instance.exports[func](...params);

      const resultRes = result === expected;
      console.assert(resultRes, `‚ùå ${name} should return ${expected}, got ${result}`);
      results.push(resultRes);
      if (debug) {
        console.log(`Debug: ${name} - Expected: ${expected}, Got: ${result}`);
      }
      if (resultRes) {
        console.log(`‚úÖ ${name} test passed!`);
      } else {
        console.error(`‚ùå ${name} test failed.`);
      }
    }

    // Check that the table contains the correct function references
    const f1Reference = instance.exports.tbl.get(0);
    const f2Reference = instance.exports.tbl.get(1);

    assert.strictEqual(typeof f1Reference, 'function', 'Table entry 0 should be a function');
    assert.strictEqual(typeof f2Reference, 'function', 'Table entry 1 should be a function');

    // Check that the functions in the table behave correctly
    assert.strictEqual(f1Reference(), 42, 'Function at table[0] should return 42');
    assert.strictEqual(f2Reference(), 43, 'Function at table[1] should return 43');

    // Test the get_func function that uses table.get
    assert.strictEqual(typeof instance.exports.get_func, 'function', 'get_func should be exported');
    const getFuncResult0 = instance.exports.get_func(0);
    const getFuncResult1 = instance.exports.get_func(1);

    assert.strictEqual(typeof getFuncResult0, 'function', 'get_func(0) should return a function');
    assert.strictEqual(typeof getFuncResult1, 'function', 'get_func(1) should return a function');
    assert.strictEqual(getFuncResult0(), 42, 'get_func(0) should return function equivalent to f1');
    assert.strictEqual(getFuncResult1(), 43, 'get_func(1) should return function equivalent to f2');

    // Test that table.set works correctly
    assert.strictEqual(typeof instance.exports.set_func, 'function', 'set_func should be exported');
    instance.exports.set_func(0, instance.exports.f2); // Set index 0 to f2
    instance.exports.set_func(1, instance.exports.f1); // Set index 1 to f1

    // Verify that the table entries were swapped
    const swappedFunc0 = instance.exports.get_func(0);
    const swappedFunc1 = instance.exports.get_func(1);
    assert.strictEqual(swappedFunc0(), 43, 'After swap, table[0] should return 43');
    assert.strictEqual(swappedFunc1(), 42, 'After swap, table[1] should return 42');

    console.log('‚úÖ Table and element section successfully verified');

    return true;
  } catch (error) {
    console.error('‚ùå Test failed:', error);
    return false;
  }
}

export default testTableFuncref;